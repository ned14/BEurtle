# Copyright (C) 2008-2011 Oracle Corporation
#
# This file is part of a free software library; you can redistribute
# it and/or modify it under the terms of the GNU Lesser General
# Public License version 2.1 as published by the Free Software
# Foundation and shipped in the "COPYING.LIB" file with this library.
# The library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY of any kind.
#
# Oracle LGPL Disclaimer: For the avoidance of doubt, except that if
# any license choice other than GPL or LGPL is available it will
# apply instead, Oracle elects to use only the Lesser General Public
# License version 2.1 (LGPLv2) at this time for any software where
# a choice of LGPL license versions is made available with the
# language indicating that LGPLv2 or any later version may be used,
# or where a choice of which version of the LGPL is applied is
# otherwise unspecified.
#
# This file is autogenerated from VirtualBox.xidl, DO NOT EDIT!
#
from VirtualBox_services import *

try:
  from VirtualBox_client import *
except:
  pass

class ManagedManager:
  def __init__(self):
     self.map = {}

  def register(self,handle):
     if handle == None:
        return
     c = self.map.get(handle,0)
     c = c + 1
     self.map[handle]=c

  def unregister(self,handle):
     if handle == None:
        return
     c = self.map.get(handle,-1)
     if c == -1:
        raise Error, 'wrong refcount'
     c = c - 1
     if c == 0:
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass
        self.map[handle] = -1
     else:
        self.map[handle] = c

class String:
  def __init__(self, mgr, handle, isarray = False):
      self.handle = handle
      self.mgr = mgr
      self.isarray = isarray

  def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

  def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

  def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

  def __getitem__(self, index):
      if self.isarray:
          return String(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

  def __str__(self):
      return str(self.handle)

  def __eq__(self,other):
      if self.isarray:
         return isinstance(other,String) and self.handle == other.handle
      if isinstance(other,String):
         return self.handle == other.handle
      if isinstance(other,basestring):
         return self.handle == other
      return False

  def __ne__(self,other):
      if self.isarray:
         return not isinstance(other,String) or self.handle != other.handle
      if isinstance(other,String):
         return self.handle != other.handle
      if isinstance(other,basestring):
         return self.handle != other
      return True

  def __add__(self,other):
      return str(self.handle)+str(other)


class Boolean:
  def __init__(self, mgr, handle, isarray = False):
       self.handle = handle
       if self.handle == "false":
          self.handle = None
       self.mgr = mgr
       self.isarray = isarray

  def __str__(self):
       if self.handle:
         return "true"
       else:
         return "false"

  def __eq__(self,other):
      if isinstance(other,Bool):
         return self.handle == other.value
      if isinstance(other,bool):
         return self.handle == other
      return False

  def __ne__(self,other):
      if isinstance(other,Bool):
         return self.handle != other.handle
      if isinstance(other,bool):
         return self.handle != other
      return True

  def __int__(self):
      if self.handle:
        return 1
      else:
        return 0

  def __long__(self):
      if self.handle:
        return 1
      else:
        return 0

  def __nonzero__(self):
      if self.handle:
        return True
      else:
        return False

  def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

  def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

  def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

  def __getitem__(self, index):
      if self.isarray:
          return Boolean(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

class Number:
  def __init__(self, mgr, handle, isarray = False):
       self.handle = handle
       self.mgr = mgr
       self.isarray = isarray

  def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

  def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

  def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

  def __str__(self):
       return str(self.handle)

  def __int__(self):
       return int(self.handle)

  def __long__(self):
       return long(self.handle)

  def __float__(self):
       return float(self.handle)

  def __lt__(self, other):
       if self.isarray:
            return NotImplemented
       else:
            return self.handle < other

  def __le__(self, other):
       if self.isarray:
            return NotImplemented
       else:
            return self.handle <= other

  def __eq__(self, other):
       return self.handle == other

  def __ne__(self, other):
       return self.handle != other

  def __gt__(self, other):
       if self.isarray:
            return NotImplemented
       else:
            return self.handle > other

  def __ge__(self, other):
       if self.isarray:
            return NotImplemented
       else:
            return self.handle >= other

class Octet:
  def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       self.isarray = isarray
       if isarray:
           self.handle = mgr.decodebase64(handle)
       else:
           raise TypeError, "only octet arrays"

  def __getitem__(self, index):
      return self.handle[index]

  def __str__(self):
       return str(self.handle)

  def __len__(self):
      return self.handle.__len__()

class UnsignedInt(Number):
  def __init__(self, mgr, handle, isarray = False):
       self.handle = handle
       self.mgr = mgr
       self.isarray = isarray

  def __getitem__(self, index):
      if self.isarray:
          return UnsignedInt(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"


class Int(Number):
  def __init__(self, mgr, handle, isarray = False):
       self.handle = handle
       self.mgr = mgr
       self.isarray = isarray

  def __getitem__(self, index):
      if self.isarray:
          return Int(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

class UnsignedShort(Number):
  def __init__(self, mgr, handle, isarray = False):
       self.handle = handle
       self.mgr = mgr
       self.isarray = isarray

  def __getitem__(self, index):
      if self.isarray:
          return UnsignedShort(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

class Short(Number):
  def __init__(self, mgr, handle, isarray = False):
       self.handle = handle
       self.mgr = mgr
       self.isarray = isarray

  def __getitem__(self, index):
      if self.isarray:
          return Short(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

class UnsignedLong(Number):
  def __init__(self, mgr, handle, isarray = False):
       self.handle = handle
       self.mgr = mgr
       self.isarray = isarray

  def __getitem__(self, index):
      if self.isarray:
          return UnsignedLong(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

class Long(Number):
  def __init__(self, mgr, handle, isarray = False):
       self.handle = handle
       self.mgr = mgr
       self.isarray = isarray

  def __getitem__(self, index):
      if self.isarray:
          return Long(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

class Double(Number):
  def __init__(self, mgr, handle, isarray = False):
       self.handle = handle
       self.mgr = mgr
       self.isarray = isarray

  def __getitem__(self, index):
      if self.isarray:
          return Double(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

class Float(Number):
  def __init__(self, mgr, handle, isarray = False):
       self.handle = handle
       self.mgr = mgr
       self.isarray = isarray

  def __getitem__(self, index):
      if self.isarray:
          return Float(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

class IUnknown:
  def __init__(self,  mgr, handle, isarray = False):
       self.handle = handle
       self.mgr = mgr
       self.isarray = isarray

  def __nonzero__(self):
      if self.handle != "":
           return True
      else:
           return False

  def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

  def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

  def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

  def __getitem__(self, index):
      if self.isarray:
          return IUnknown(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

  def __str__(self):
       return str(self.handle)

  def __eq__(self, other):
       return self.handle == other

  def __ne__(self, other):
       return self.handle != other

  def __getattr__(self,attr):
       if self.__class__.__dict__.get(attr) != None:
           return self.__class__.__dict__.get(attr)
       if self.__dict__.get(attr) != None:
           return self.__dict__.get(attr)
       raise AttributeError



class IVirtualBoxErrorInfo(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IVirtualBoxErrorInfo(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IVirtualBoxErrorInfo._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IVirtualBoxErrorInfo._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getResultCode(self):
       req=IVirtualBoxErrorInfo_getResultCodeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVirtualBoxErrorInfo_getResultCode(req)
       return  Int(self.mgr,val._returnval)
   def getInterfaceID(self):
       req=IVirtualBoxErrorInfo_getInterfaceIDRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVirtualBoxErrorInfo_getInterfaceID(req)
       return  String(self.mgr,val._returnval)
   def getComponent(self):
       req=IVirtualBoxErrorInfo_getComponentRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVirtualBoxErrorInfo_getComponent(req)
       return  String(self.mgr,val._returnval)
   def getText(self):
       req=IVirtualBoxErrorInfo_getTextRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVirtualBoxErrorInfo_getText(req)
       return  String(self.mgr,val._returnval)
   def getNext(self):
       req=IVirtualBoxErrorInfo_getNextRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVirtualBoxErrorInfo_getNext(req)
       return  IVirtualBoxErrorInfo(self.mgr,val._returnval)


   _Attrs_={         'resultCode':[getResultCode,None],
         'interfaceID':[getInterfaceID,None],
         'component':[getComponent,None],
         'text':[getText,None],
         'next':[getNext,None]}

class IDHCPServer(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IDHCPServer(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IDHCPServer._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IDHCPServer._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def setConfiguration(self, _arg_IPAddress, _arg_networkMask, _arg_FromIPAddress, _arg_ToIPAddress):
       req=IDHCPServer_setConfigurationRequestMsg()
       req._this=self.handle
       
       req._IPAddress=_arg_IPAddress
       req._networkMask=_arg_networkMask
       req._FromIPAddress=_arg_FromIPAddress
       req._ToIPAddress=_arg_ToIPAddress
       val=self.mgr.getPort().IDHCPServer_setConfiguration(req)
       
       return 


   def start(self, _arg_networkName, _arg_trunkName, _arg_trunkType):
       req=IDHCPServer_startRequestMsg()
       req._this=self.handle
       
       req._networkName=_arg_networkName
       req._trunkName=_arg_trunkName
       req._trunkType=_arg_trunkType
       val=self.mgr.getPort().IDHCPServer_start(req)
       
       return 


   def stop(self):
       req=IDHCPServer_stopRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IDHCPServer_stop(req)
       
       return 


   def getEnabled(self):
       req=IDHCPServer_getEnabledRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IDHCPServer_getEnabled(req)
       return  Boolean(self.mgr,val._returnval)
   def setEnabled(self, value):
       req=IDHCPServer_setEnabledRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._enabled = value
       else:
            req._enabled = value.handle
       self.mgr.getPort().IDHCPServer_setEnabled(req)

   def getIPAddress(self):
       req=IDHCPServer_getIPAddressRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IDHCPServer_getIPAddress(req)
       return  String(self.mgr,val._returnval)
   def getNetworkMask(self):
       req=IDHCPServer_getNetworkMaskRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IDHCPServer_getNetworkMask(req)
       return  String(self.mgr,val._returnval)
   def getNetworkName(self):
       req=IDHCPServer_getNetworkNameRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IDHCPServer_getNetworkName(req)
       return  String(self.mgr,val._returnval)
   def getLowerIP(self):
       req=IDHCPServer_getLowerIPRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IDHCPServer_getLowerIP(req)
       return  String(self.mgr,val._returnval)
   def getUpperIP(self):
       req=IDHCPServer_getUpperIPRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IDHCPServer_getUpperIP(req)
       return  String(self.mgr,val._returnval)


   _Attrs_={         'enabled':[getEnabled,setEnabled,
        ],
         'IPAddress':[getIPAddress,None],
         'networkMask':[getNetworkMask,None],
         'networkName':[getNetworkName,None],
         'lowerIP':[getLowerIP,None],
         'upperIP':[getUpperIP,None]}

class IVirtualBox(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IVirtualBox(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IVirtualBox._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IVirtualBox._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def composeMachineFilename(self, _arg_name, _arg_baseFolder):
       req=IVirtualBox_composeMachineFilenameRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       req._baseFolder=_arg_baseFolder
       val=self.mgr.getPort().IVirtualBox_composeMachineFilename(req)
       
       return String(self.mgr,val._returnval)


   def createMachine(self, _arg_settingsFile, _arg_name, _arg_osTypeId, _arg_id, _arg_forceOverwrite):
       req=IVirtualBox_createMachineRequestMsg()
       req._this=self.handle
       
       req._settingsFile=_arg_settingsFile
       req._name=_arg_name
       req._osTypeId=_arg_osTypeId
       req._id=_arg_id
       req._forceOverwrite=_arg_forceOverwrite
       val=self.mgr.getPort().IVirtualBox_createMachine(req)
       
       return IMachine(self.mgr,val._returnval)


   def openMachine(self, _arg_settingsFile):
       req=IVirtualBox_openMachineRequestMsg()
       req._this=self.handle
       
       req._settingsFile=_arg_settingsFile
       val=self.mgr.getPort().IVirtualBox_openMachine(req)
       
       return IMachine(self.mgr,val._returnval)


   def registerMachine(self, _arg_machine):
       req=IVirtualBox_registerMachineRequestMsg()
       req._this=self.handle
       
       req._machine=_arg_machine
       val=self.mgr.getPort().IVirtualBox_registerMachine(req)
       
       return 


   def findMachine(self, _arg_nameOrId):
       req=IVirtualBox_findMachineRequestMsg()
       req._this=self.handle
       
       req._nameOrId=_arg_nameOrId
       val=self.mgr.getPort().IVirtualBox_findMachine(req)
       
       return IMachine(self.mgr,val._returnval)


   def createAppliance(self):
       req=IVirtualBox_createApplianceRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IVirtualBox_createAppliance(req)
       
       return IAppliance(self.mgr,val._returnval)


   def createHardDisk(self, _arg_format, _arg_location):
       req=IVirtualBox_createHardDiskRequestMsg()
       req._this=self.handle
       
       req._format=_arg_format
       req._location=_arg_location
       val=self.mgr.getPort().IVirtualBox_createHardDisk(req)
       
       return IMedium(self.mgr,val._returnval)


   def openMedium(self, _arg_location, _arg_deviceType, _arg_accessMode, _arg_forceNewUuid):
       req=IVirtualBox_openMediumRequestMsg()
       req._this=self.handle
       
       req._location=_arg_location
       req._deviceType=_arg_deviceType
       req._accessMode=_arg_accessMode
       req._forceNewUuid=_arg_forceNewUuid
       val=self.mgr.getPort().IVirtualBox_openMedium(req)
       
       return IMedium(self.mgr,val._returnval)


   def findMedium(self, _arg_location, _arg_type):
       req=IVirtualBox_findMediumRequestMsg()
       req._this=self.handle
       
       req._location=_arg_location
       req._type=_arg_type
       val=self.mgr.getPort().IVirtualBox_findMedium(req)
       
       return IMedium(self.mgr,val._returnval)


   def getGuestOSType(self, _arg_id):
       req=IVirtualBox_getGuestOSTypeRequestMsg()
       req._this=self.handle
       
       req._id=_arg_id
       val=self.mgr.getPort().IVirtualBox_getGuestOSType(req)
       
       return IGuestOSType(self.mgr,val._returnval)


   def createSharedFolder(self, _arg_name, _arg_hostPath, _arg_writable, _arg_automount):
       req=IVirtualBox_createSharedFolderRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       req._hostPath=_arg_hostPath
       req._writable=_arg_writable
       req._automount=_arg_automount
       val=self.mgr.getPort().IVirtualBox_createSharedFolder(req)
       
       return 


   def removeSharedFolder(self, _arg_name):
       req=IVirtualBox_removeSharedFolderRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       val=self.mgr.getPort().IVirtualBox_removeSharedFolder(req)
       
       return 


   def getExtraDataKeys(self):
       req=IVirtualBox_getExtraDataKeysRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IVirtualBox_getExtraDataKeys(req)
       
       return String(self.mgr,val._returnval, True)


   def getExtraData(self, _arg_key):
       req=IVirtualBox_getExtraDataRequestMsg()
       req._this=self.handle
       
       req._key=_arg_key
       val=self.mgr.getPort().IVirtualBox_getExtraData(req)
       
       return String(self.mgr,val._returnval)


   def setExtraData(self, _arg_key, _arg_value):
       req=IVirtualBox_setExtraDataRequestMsg()
       req._this=self.handle
       
       req._key=_arg_key
       req._value=_arg_value
       val=self.mgr.getPort().IVirtualBox_setExtraData(req)
       
       return 


   def createDHCPServer(self, _arg_name):
       req=IVirtualBox_createDHCPServerRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       val=self.mgr.getPort().IVirtualBox_createDHCPServer(req)
       
       return IDHCPServer(self.mgr,val._returnval)


   def findDHCPServerByNetworkName(self, _arg_name):
       req=IVirtualBox_findDHCPServerByNetworkNameRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       val=self.mgr.getPort().IVirtualBox_findDHCPServerByNetworkName(req)
       
       return IDHCPServer(self.mgr,val._returnval)


   def removeDHCPServer(self, _arg_server):
       req=IVirtualBox_removeDHCPServerRequestMsg()
       req._this=self.handle
       
       req._server=_arg_server
       val=self.mgr.getPort().IVirtualBox_removeDHCPServer(req)
       
       return 


   def checkFirmwarePresent(self, _arg_firmwareType, _arg_version):
       req=IVirtualBox_checkFirmwarePresentRequestMsg()
       req._this=self.handle
       
       req._firmwareType=_arg_firmwareType
       req._version=_arg_version
       val=self.mgr.getPort().IVirtualBox_checkFirmwarePresent(req)
       
       return Boolean(self.mgr,val._returnval), String(self.mgr,val._url), String(self.mgr,val._file)


   def getVersion(self):
       req=IVirtualBox_getVersionRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVirtualBox_getVersion(req)
       return  String(self.mgr,val._returnval)
   def getRevision(self):
       req=IVirtualBox_getRevisionRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVirtualBox_getRevision(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getPackageType(self):
       req=IVirtualBox_getPackageTypeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVirtualBox_getPackageType(req)
       return  String(self.mgr,val._returnval)
   def getAPIVersion(self):
       req=IVirtualBox_getAPIVersionRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVirtualBox_getAPIVersion(req)
       return  String(self.mgr,val._returnval)
   def getHomeFolder(self):
       req=IVirtualBox_getHomeFolderRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVirtualBox_getHomeFolder(req)
       return  String(self.mgr,val._returnval)
   def getSettingsFilePath(self):
       req=IVirtualBox_getSettingsFilePathRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVirtualBox_getSettingsFilePath(req)
       return  String(self.mgr,val._returnval)
   def getHost(self):
       req=IVirtualBox_getHostRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVirtualBox_getHost(req)
       return  IHost(self.mgr,val._returnval)
   def getSystemProperties(self):
       req=IVirtualBox_getSystemPropertiesRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVirtualBox_getSystemProperties(req)
       return  ISystemProperties(self.mgr,val._returnval)
   def getMachines(self):
       req=IVirtualBox_getMachinesRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVirtualBox_getMachines(req)
       return  IMachine(self.mgr,val._returnval, True)
   def getHardDisks(self):
       req=IVirtualBox_getHardDisksRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVirtualBox_getHardDisks(req)
       return  IMedium(self.mgr,val._returnval, True)
   def getDVDImages(self):
       req=IVirtualBox_getDVDImagesRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVirtualBox_getDVDImages(req)
       return  IMedium(self.mgr,val._returnval, True)
   def getFloppyImages(self):
       req=IVirtualBox_getFloppyImagesRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVirtualBox_getFloppyImages(req)
       return  IMedium(self.mgr,val._returnval, True)
   def getProgressOperations(self):
       req=IVirtualBox_getProgressOperationsRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVirtualBox_getProgressOperations(req)
       return  IProgress(self.mgr,val._returnval, True)
   def getGuestOSTypes(self):
       req=IVirtualBox_getGuestOSTypesRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVirtualBox_getGuestOSTypes(req)
       return  IGuestOSType(self.mgr,val._returnval, True)
   def getSharedFolders(self):
       req=IVirtualBox_getSharedFoldersRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVirtualBox_getSharedFolders(req)
       return  ISharedFolder(self.mgr,val._returnval, True)
   def getPerformanceCollector(self):
       req=IVirtualBox_getPerformanceCollectorRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVirtualBox_getPerformanceCollector(req)
       return  IPerformanceCollector(self.mgr,val._returnval)
   def getDHCPServers(self):
       req=IVirtualBox_getDHCPServersRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVirtualBox_getDHCPServers(req)
       return  IDHCPServer(self.mgr,val._returnval, True)
   def getEventSource(self):
       req=IVirtualBox_getEventSourceRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVirtualBox_getEventSource(req)
       return  IEventSource(self.mgr,val._returnval)
   def getInternalNetworks(self):
       req=IVirtualBox_getInternalNetworksRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVirtualBox_getInternalNetworks(req)
       return  String(self.mgr,val._returnval, True)
   def getGenericNetworkDrivers(self):
       req=IVirtualBox_getGenericNetworkDriversRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVirtualBox_getGenericNetworkDrivers(req)
       return  String(self.mgr,val._returnval, True)


   _Attrs_={         'version':[getVersion,None],
         'revision':[getRevision,None],
         'packageType':[getPackageType,None],
         'APIVersion':[getAPIVersion,None],
         'homeFolder':[getHomeFolder,None],
         'settingsFilePath':[getSettingsFilePath,None],
         'host':[getHost,None],
         'systemProperties':[getSystemProperties,None],
         'machines':[getMachines,None],
         'hardDisks':[getHardDisks,None],
         'DVDImages':[getDVDImages,None],
         'floppyImages':[getFloppyImages,None],
         'progressOperations':[getProgressOperations,None],
         'guestOSTypes':[getGuestOSTypes,None],
         'sharedFolders':[getSharedFolders,None],
         'performanceCollector':[getPerformanceCollector,None],
         'DHCPServers':[getDHCPServers,None],
         'eventSource':[getEventSource,None],
         'internalNetworks':[getInternalNetworks,None],
         'genericNetworkDrivers':[getGenericNetworkDrivers,None]}

class IVFSExplorer(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IVFSExplorer(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IVFSExplorer._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IVFSExplorer._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def update(self):
       req=IVFSExplorer_updateRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IVFSExplorer_update(req)
       
       return IProgress(self.mgr,val._returnval)


   def cd(self, _arg_aDir):
       req=IVFSExplorer_cdRequestMsg()
       req._this=self.handle
       
       req._aDir=_arg_aDir
       val=self.mgr.getPort().IVFSExplorer_cd(req)
       
       return IProgress(self.mgr,val._returnval)


   def cdUp(self):
       req=IVFSExplorer_cdUpRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IVFSExplorer_cdUp(req)
       
       return IProgress(self.mgr,val._returnval)


   def entryList(self):
       req=IVFSExplorer_entryListRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IVFSExplorer_entryList(req)
       
       return String(self.mgr,val._aNames, True), UnsignedInt(self.mgr,val._aTypes, True), UnsignedInt(self.mgr,val._aSizes, True), UnsignedInt(self.mgr,val._aModes, True)


   def exists(self, _arg_aNames):
       req=IVFSExplorer_existsRequestMsg()
       req._this=self.handle
       
       req._aNames=_arg_aNames
       val=self.mgr.getPort().IVFSExplorer_exists(req)
       
       return String(self.mgr,val._returnval, True)


   def remove(self, _arg_aNames):
       req=IVFSExplorer_removeRequestMsg()
       req._this=self.handle
       
       req._aNames=_arg_aNames
       val=self.mgr.getPort().IVFSExplorer_remove(req)
       
       return IProgress(self.mgr,val._returnval)


   def getPath(self):
       req=IVFSExplorer_getPathRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVFSExplorer_getPath(req)
       return  String(self.mgr,val._returnval)
   def getType(self):
       req=IVFSExplorer_getTypeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVFSExplorer_getType(req)
       return  VFSType(self.mgr,val._returnval)


   _Attrs_={         'path':[getPath,None],
         'type':[getType,None]}

class IAppliance(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IAppliance(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IAppliance._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IAppliance._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def read(self, _arg_file):
       req=IAppliance_readRequestMsg()
       req._this=self.handle
       
       req._file=_arg_file
       val=self.mgr.getPort().IAppliance_read(req)
       
       return IProgress(self.mgr,val._returnval)


   def interpret(self):
       req=IAppliance_interpretRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IAppliance_interpret(req)
       
       return 


   def importMachines(self, _arg_options):
       req=IAppliance_importMachinesRequestMsg()
       req._this=self.handle
       
       req._options=_arg_options
       val=self.mgr.getPort().IAppliance_importMachines(req)
       
       return IProgress(self.mgr,val._returnval)


   def createVFSExplorer(self, _arg_aUri):
       req=IAppliance_createVFSExplorerRequestMsg()
       req._this=self.handle
       
       req._aUri=_arg_aUri
       val=self.mgr.getPort().IAppliance_createVFSExplorer(req)
       
       return IVFSExplorer(self.mgr,val._returnval)


   def write(self, _arg_format, _arg_manifest, _arg_path):
       req=IAppliance_writeRequestMsg()
       req._this=self.handle
       
       req._format=_arg_format
       req._manifest=_arg_manifest
       req._path=_arg_path
       val=self.mgr.getPort().IAppliance_write(req)
       
       return IProgress(self.mgr,val._returnval)


   def getWarnings(self):
       req=IAppliance_getWarningsRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IAppliance_getWarnings(req)
       
       return String(self.mgr,val._returnval, True)


   def getPath(self):
       req=IAppliance_getPathRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IAppliance_getPath(req)
       return  String(self.mgr,val._returnval)
   def getDisks(self):
       req=IAppliance_getDisksRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IAppliance_getDisks(req)
       return  String(self.mgr,val._returnval, True)
   def getVirtualSystemDescriptions(self):
       req=IAppliance_getVirtualSystemDescriptionsRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IAppliance_getVirtualSystemDescriptions(req)
       return  IVirtualSystemDescription(self.mgr,val._returnval, True)
   def getMachines(self):
       req=IAppliance_getMachinesRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IAppliance_getMachines(req)
       return  String(self.mgr,val._returnval, True)


   _Attrs_={         'path':[getPath,None],
         'disks':[getDisks,None],
         'virtualSystemDescriptions':[getVirtualSystemDescriptions,None],
         'machines':[getMachines,None]}

class IVirtualSystemDescription(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IVirtualSystemDescription(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IVirtualSystemDescription._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IVirtualSystemDescription._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getDescription(self):
       req=IVirtualSystemDescription_getDescriptionRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IVirtualSystemDescription_getDescription(req)
       
       return VirtualSystemDescriptionType(self.mgr,val._aTypes, True), String(self.mgr,val._aRefs, True), String(self.mgr,val._aOvfValues, True), String(self.mgr,val._aVBoxValues, True), String(self.mgr,val._aExtraConfigValues, True)


   def getDescriptionByType(self, _arg_aType):
       req=IVirtualSystemDescription_getDescriptionByTypeRequestMsg()
       req._this=self.handle
       
       req._aType=_arg_aType
       val=self.mgr.getPort().IVirtualSystemDescription_getDescriptionByType(req)
       
       return VirtualSystemDescriptionType(self.mgr,val._aTypes, True), String(self.mgr,val._aRefs, True), String(self.mgr,val._aOvfValues, True), String(self.mgr,val._aVBoxValues, True), String(self.mgr,val._aExtraConfigValues, True)


   def getValuesByType(self, _arg_aType, _arg_aWhich):
       req=IVirtualSystemDescription_getValuesByTypeRequestMsg()
       req._this=self.handle
       
       req._aType=_arg_aType
       req._aWhich=_arg_aWhich
       val=self.mgr.getPort().IVirtualSystemDescription_getValuesByType(req)
       
       return String(self.mgr,val._returnval, True)


   def setFinalValues(self, _arg_aEnabled, _arg_aVBoxValues, _arg_aExtraConfigValues):
       req=IVirtualSystemDescription_setFinalValuesRequestMsg()
       req._this=self.handle
       
       req._aEnabled=_arg_aEnabled
       req._aVBoxValues=_arg_aVBoxValues
       req._aExtraConfigValues=_arg_aExtraConfigValues
       val=self.mgr.getPort().IVirtualSystemDescription_setFinalValues(req)
       
       return 


   def addDescription(self, _arg_aType, _arg_aVBoxValue, _arg_aExtraConfigValue):
       req=IVirtualSystemDescription_addDescriptionRequestMsg()
       req._this=self.handle
       
       req._aType=_arg_aType
       req._aVBoxValue=_arg_aVBoxValue
       req._aExtraConfigValue=_arg_aExtraConfigValue
       val=self.mgr.getPort().IVirtualSystemDescription_addDescription(req)
       
       return 


   def getCount(self):
       req=IVirtualSystemDescription_getCountRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVirtualSystemDescription_getCount(req)
       return  UnsignedInt(self.mgr,val._returnval)


   _Attrs_={         'count':[getCount,None]}

class IBIOSSettings(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IBIOSSettings(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IBIOSSettings._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IBIOSSettings._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getLogoFadeIn(self):
       req=IBIOSSettings_getLogoFadeInRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IBIOSSettings_getLogoFadeIn(req)
       return  Boolean(self.mgr,val._returnval)
   def setLogoFadeIn(self, value):
       req=IBIOSSettings_setLogoFadeInRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._logoFadeIn = value
       else:
            req._logoFadeIn = value.handle
       self.mgr.getPort().IBIOSSettings_setLogoFadeIn(req)

   def getLogoFadeOut(self):
       req=IBIOSSettings_getLogoFadeOutRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IBIOSSettings_getLogoFadeOut(req)
       return  Boolean(self.mgr,val._returnval)
   def setLogoFadeOut(self, value):
       req=IBIOSSettings_setLogoFadeOutRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._logoFadeOut = value
       else:
            req._logoFadeOut = value.handle
       self.mgr.getPort().IBIOSSettings_setLogoFadeOut(req)

   def getLogoDisplayTime(self):
       req=IBIOSSettings_getLogoDisplayTimeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IBIOSSettings_getLogoDisplayTime(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def setLogoDisplayTime(self, value):
       req=IBIOSSettings_setLogoDisplayTimeRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._logoDisplayTime = value
       else:
            req._logoDisplayTime = value.handle
       self.mgr.getPort().IBIOSSettings_setLogoDisplayTime(req)

   def getLogoImagePath(self):
       req=IBIOSSettings_getLogoImagePathRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IBIOSSettings_getLogoImagePath(req)
       return  String(self.mgr,val._returnval)
   def setLogoImagePath(self, value):
       req=IBIOSSettings_setLogoImagePathRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._logoImagePath = value
       else:
            req._logoImagePath = value.handle
       self.mgr.getPort().IBIOSSettings_setLogoImagePath(req)

   def getBootMenuMode(self):
       req=IBIOSSettings_getBootMenuModeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IBIOSSettings_getBootMenuMode(req)
       return  BIOSBootMenuMode(self.mgr,val._returnval)
   def setBootMenuMode(self, value):
       req=IBIOSSettings_setBootMenuModeRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._bootMenuMode = value
       else:
            req._bootMenuMode = value.handle
       self.mgr.getPort().IBIOSSettings_setBootMenuMode(req)

   def getACPIEnabled(self):
       req=IBIOSSettings_getACPIEnabledRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IBIOSSettings_getACPIEnabled(req)
       return  Boolean(self.mgr,val._returnval)
   def setACPIEnabled(self, value):
       req=IBIOSSettings_setACPIEnabledRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._ACPIEnabled = value
       else:
            req._ACPIEnabled = value.handle
       self.mgr.getPort().IBIOSSettings_setACPIEnabled(req)

   def getIOAPICEnabled(self):
       req=IBIOSSettings_getIOAPICEnabledRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IBIOSSettings_getIOAPICEnabled(req)
       return  Boolean(self.mgr,val._returnval)
   def setIOAPICEnabled(self, value):
       req=IBIOSSettings_setIOAPICEnabledRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._IOAPICEnabled = value
       else:
            req._IOAPICEnabled = value.handle
       self.mgr.getPort().IBIOSSettings_setIOAPICEnabled(req)

   def getTimeOffset(self):
       req=IBIOSSettings_getTimeOffsetRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IBIOSSettings_getTimeOffset(req)
       return  Long(self.mgr,val._returnval)
   def setTimeOffset(self, value):
       req=IBIOSSettings_setTimeOffsetRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._timeOffset = value
       else:
            req._timeOffset = value.handle
       self.mgr.getPort().IBIOSSettings_setTimeOffset(req)

   def getPXEDebugEnabled(self):
       req=IBIOSSettings_getPXEDebugEnabledRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IBIOSSettings_getPXEDebugEnabled(req)
       return  Boolean(self.mgr,val._returnval)
   def setPXEDebugEnabled(self, value):
       req=IBIOSSettings_setPXEDebugEnabledRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._PXEDebugEnabled = value
       else:
            req._PXEDebugEnabled = value.handle
       self.mgr.getPort().IBIOSSettings_setPXEDebugEnabled(req)



   _Attrs_={         'logoFadeIn':[getLogoFadeIn,setLogoFadeIn,
        ],
         'logoFadeOut':[getLogoFadeOut,setLogoFadeOut,
        ],
         'logoDisplayTime':[getLogoDisplayTime,setLogoDisplayTime,
        ],
         'logoImagePath':[getLogoImagePath,setLogoImagePath,
        ],
         'bootMenuMode':[getBootMenuMode,setBootMenuMode,
        ],
         'ACPIEnabled':[getACPIEnabled,setACPIEnabled,
        ],
         'IOAPICEnabled':[getIOAPICEnabled,setIOAPICEnabled,
        ],
         'timeOffset':[getTimeOffset,setTimeOffset,
        ],
         'PXEDebugEnabled':[getPXEDebugEnabled,setPXEDebugEnabled,
        ]}

class IMachine(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IMachine(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IMachine._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IMachine._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def lockMachine(self, _arg_session, _arg_lockType):
       req=IMachine_lockMachineRequestMsg()
       req._this=self.handle
       
       req._session=_arg_session
       req._lockType=_arg_lockType
       val=self.mgr.getPort().IMachine_lockMachine(req)
       
       return 


   def launchVMProcess(self, _arg_session, _arg_type, _arg_environment):
       req=IMachine_launchVMProcessRequestMsg()
       req._this=self.handle
       
       req._session=_arg_session
       req._type=_arg_type
       req._environment=_arg_environment
       val=self.mgr.getPort().IMachine_launchVMProcess(req)
       
       return IProgress(self.mgr,val._returnval)


   def setBootOrder(self, _arg_position, _arg_device):
       req=IMachine_setBootOrderRequestMsg()
       req._this=self.handle
       
       req._position=_arg_position
       req._device=_arg_device
       val=self.mgr.getPort().IMachine_setBootOrder(req)
       
       return 


   def getBootOrder(self, _arg_position):
       req=IMachine_getBootOrderRequestMsg()
       req._this=self.handle
       
       req._position=_arg_position
       val=self.mgr.getPort().IMachine_getBootOrder(req)
       
       return DeviceType(self.mgr,val._returnval)


   def attachDevice(self, _arg_name, _arg_controllerPort, _arg_device, _arg_type, _arg_medium):
       req=IMachine_attachDeviceRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       req._controllerPort=_arg_controllerPort
       req._device=_arg_device
       req._type=_arg_type
       req._medium=_arg_medium
       val=self.mgr.getPort().IMachine_attachDevice(req)
       
       return 


   def detachDevice(self, _arg_name, _arg_controllerPort, _arg_device):
       req=IMachine_detachDeviceRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       req._controllerPort=_arg_controllerPort
       req._device=_arg_device
       val=self.mgr.getPort().IMachine_detachDevice(req)
       
       return 


   def passthroughDevice(self, _arg_name, _arg_controllerPort, _arg_device, _arg_passthrough):
       req=IMachine_passthroughDeviceRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       req._controllerPort=_arg_controllerPort
       req._device=_arg_device
       req._passthrough=_arg_passthrough
       val=self.mgr.getPort().IMachine_passthroughDevice(req)
       
       return 


   def temporaryEjectDevice(self, _arg_name, _arg_controllerPort, _arg_device, _arg_temporaryEject):
       req=IMachine_temporaryEjectDeviceRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       req._controllerPort=_arg_controllerPort
       req._device=_arg_device
       req._temporaryEject=_arg_temporaryEject
       val=self.mgr.getPort().IMachine_temporaryEjectDevice(req)
       
       return 


   def nonRotationalDevice(self, _arg_name, _arg_controllerPort, _arg_device, _arg_nonRotational):
       req=IMachine_nonRotationalDeviceRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       req._controllerPort=_arg_controllerPort
       req._device=_arg_device
       req._nonRotational=_arg_nonRotational
       val=self.mgr.getPort().IMachine_nonRotationalDevice(req)
       
       return 


   def setBandwidthGroupForDevice(self, _arg_name, _arg_controllerPort, _arg_device, _arg_bandwidthGroup):
       req=IMachine_setBandwidthGroupForDeviceRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       req._controllerPort=_arg_controllerPort
       req._device=_arg_device
       req._bandwidthGroup=_arg_bandwidthGroup
       val=self.mgr.getPort().IMachine_setBandwidthGroupForDevice(req)
       
       return 


   def mountMedium(self, _arg_name, _arg_controllerPort, _arg_device, _arg_medium, _arg_force):
       req=IMachine_mountMediumRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       req._controllerPort=_arg_controllerPort
       req._device=_arg_device
       req._medium=_arg_medium
       req._force=_arg_force
       val=self.mgr.getPort().IMachine_mountMedium(req)
       
       return 


   def getMedium(self, _arg_name, _arg_controllerPort, _arg_device):
       req=IMachine_getMediumRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       req._controllerPort=_arg_controllerPort
       req._device=_arg_device
       val=self.mgr.getPort().IMachine_getMedium(req)
       
       return IMedium(self.mgr,val._returnval)


   def getMediumAttachmentsOfController(self, _arg_name):
       req=IMachine_getMediumAttachmentsOfControllerRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       val=self.mgr.getPort().IMachine_getMediumAttachmentsOfController(req)
       
       return IMediumAttachment(self.mgr,val._returnval, True)


   def getMediumAttachment(self, _arg_name, _arg_controllerPort, _arg_device):
       req=IMachine_getMediumAttachmentRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       req._controllerPort=_arg_controllerPort
       req._device=_arg_device
       val=self.mgr.getPort().IMachine_getMediumAttachment(req)
       
       return IMediumAttachment(self.mgr,val._returnval)


   def attachHostPciDevice(self, _arg_hostAddress, _arg_desiredGuestAddress, _arg_tryToUnbind):
       req=IMachine_attachHostPciDeviceRequestMsg()
       req._this=self.handle
       
       req._hostAddress=_arg_hostAddress
       req._desiredGuestAddress=_arg_desiredGuestAddress
       req._tryToUnbind=_arg_tryToUnbind
       val=self.mgr.getPort().IMachine_attachHostPciDevice(req)
       
       return 


   def detachHostPciDevice(self, _arg_hostAddress):
       req=IMachine_detachHostPciDeviceRequestMsg()
       req._this=self.handle
       
       req._hostAddress=_arg_hostAddress
       val=self.mgr.getPort().IMachine_detachHostPciDevice(req)
       
       return 


   def getNetworkAdapter(self, _arg_slot):
       req=IMachine_getNetworkAdapterRequestMsg()
       req._this=self.handle
       
       req._slot=_arg_slot
       val=self.mgr.getPort().IMachine_getNetworkAdapter(req)
       
       return INetworkAdapter(self.mgr,val._returnval)


   def addStorageController(self, _arg_name, _arg_connectionType):
       req=IMachine_addStorageControllerRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       req._connectionType=_arg_connectionType
       val=self.mgr.getPort().IMachine_addStorageController(req)
       
       return IStorageController(self.mgr,val._returnval)


   def getStorageControllerByName(self, _arg_name):
       req=IMachine_getStorageControllerByNameRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       val=self.mgr.getPort().IMachine_getStorageControllerByName(req)
       
       return IStorageController(self.mgr,val._returnval)


   def getStorageControllerByInstance(self, _arg_instance):
       req=IMachine_getStorageControllerByInstanceRequestMsg()
       req._this=self.handle
       
       req._instance=_arg_instance
       val=self.mgr.getPort().IMachine_getStorageControllerByInstance(req)
       
       return IStorageController(self.mgr,val._returnval)


   def removeStorageController(self, _arg_name):
       req=IMachine_removeStorageControllerRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       val=self.mgr.getPort().IMachine_removeStorageController(req)
       
       return 


   def setStorageControllerBootable(self, _arg_name, _arg_bootable):
       req=IMachine_setStorageControllerBootableRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       req._bootable=_arg_bootable
       val=self.mgr.getPort().IMachine_setStorageControllerBootable(req)
       
       return 


   def getSerialPort(self, _arg_slot):
       req=IMachine_getSerialPortRequestMsg()
       req._this=self.handle
       
       req._slot=_arg_slot
       val=self.mgr.getPort().IMachine_getSerialPort(req)
       
       return ISerialPort(self.mgr,val._returnval)


   def getParallelPort(self, _arg_slot):
       req=IMachine_getParallelPortRequestMsg()
       req._this=self.handle
       
       req._slot=_arg_slot
       val=self.mgr.getPort().IMachine_getParallelPort(req)
       
       return IParallelPort(self.mgr,val._returnval)


   def getExtraDataKeys(self):
       req=IMachine_getExtraDataKeysRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IMachine_getExtraDataKeys(req)
       
       return String(self.mgr,val._returnval, True)


   def getExtraData(self, _arg_key):
       req=IMachine_getExtraDataRequestMsg()
       req._this=self.handle
       
       req._key=_arg_key
       val=self.mgr.getPort().IMachine_getExtraData(req)
       
       return String(self.mgr,val._returnval)


   def setExtraData(self, _arg_key, _arg_value):
       req=IMachine_setExtraDataRequestMsg()
       req._this=self.handle
       
       req._key=_arg_key
       req._value=_arg_value
       val=self.mgr.getPort().IMachine_setExtraData(req)
       
       return 


   def getCPUProperty(self, _arg_property):
       req=IMachine_getCPUPropertyRequestMsg()
       req._this=self.handle
       
       req._property=_arg_property
       val=self.mgr.getPort().IMachine_getCPUProperty(req)
       
       return Boolean(self.mgr,val._returnval)


   def setCPUProperty(self, _arg_property, _arg_value):
       req=IMachine_setCPUPropertyRequestMsg()
       req._this=self.handle
       
       req._property=_arg_property
       req._value=_arg_value
       val=self.mgr.getPort().IMachine_setCPUProperty(req)
       
       return 


   def getCPUIDLeaf(self, _arg_id):
       req=IMachine_getCPUIDLeafRequestMsg()
       req._this=self.handle
       
       req._id=_arg_id
       val=self.mgr.getPort().IMachine_getCPUIDLeaf(req)
       
       return UnsignedInt(self.mgr,val._valEax), UnsignedInt(self.mgr,val._valEbx), UnsignedInt(self.mgr,val._valEcx), UnsignedInt(self.mgr,val._valEdx)


   def setCPUIDLeaf(self, _arg_id, _arg_valEax, _arg_valEbx, _arg_valEcx, _arg_valEdx):
       req=IMachine_setCPUIDLeafRequestMsg()
       req._this=self.handle
       
       req._id=_arg_id
       req._valEax=_arg_valEax
       req._valEbx=_arg_valEbx
       req._valEcx=_arg_valEcx
       req._valEdx=_arg_valEdx
       val=self.mgr.getPort().IMachine_setCPUIDLeaf(req)
       
       return 


   def removeCPUIDLeaf(self, _arg_id):
       req=IMachine_removeCPUIDLeafRequestMsg()
       req._this=self.handle
       
       req._id=_arg_id
       val=self.mgr.getPort().IMachine_removeCPUIDLeaf(req)
       
       return 


   def removeAllCPUIDLeaves(self):
       req=IMachine_removeAllCPUIDLeavesRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IMachine_removeAllCPUIDLeaves(req)
       
       return 


   def getHWVirtExProperty(self, _arg_property):
       req=IMachine_getHWVirtExPropertyRequestMsg()
       req._this=self.handle
       
       req._property=_arg_property
       val=self.mgr.getPort().IMachine_getHWVirtExProperty(req)
       
       return Boolean(self.mgr,val._returnval)


   def setHWVirtExProperty(self, _arg_property, _arg_value):
       req=IMachine_setHWVirtExPropertyRequestMsg()
       req._this=self.handle
       
       req._property=_arg_property
       req._value=_arg_value
       val=self.mgr.getPort().IMachine_setHWVirtExProperty(req)
       
       return 


   def saveSettings(self):
       req=IMachine_saveSettingsRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IMachine_saveSettings(req)
       
       return 


   def discardSettings(self):
       req=IMachine_discardSettingsRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IMachine_discardSettings(req)
       
       return 


   def unregister(self, _arg_cleanupMode):
       req=IMachine_unregisterRequestMsg()
       req._this=self.handle
       
       req._cleanupMode=_arg_cleanupMode
       val=self.mgr.getPort().IMachine_unregister(req)
       
       return IMedium(self.mgr,val._returnval, True)


   def delete(self, _arg_aMedia):
       req=IMachine_deleteRequestMsg()
       req._this=self.handle
       
       req._aMedia=_arg_aMedia
       val=self.mgr.getPort().IMachine_delete(req)
       
       return IProgress(self.mgr,val._returnval)


   def export(self, _arg_aAppliance, _arg_location):
       req=IMachine_exportRequestMsg()
       req._this=self.handle
       
       req._aAppliance=_arg_aAppliance
       req._location=_arg_location
       val=self.mgr.getPort().IMachine_export(req)
       
       return IVirtualSystemDescription(self.mgr,val._returnval)


   def findSnapshot(self, _arg_nameOrId):
       req=IMachine_findSnapshotRequestMsg()
       req._this=self.handle
       
       req._nameOrId=_arg_nameOrId
       val=self.mgr.getPort().IMachine_findSnapshot(req)
       
       return ISnapshot(self.mgr,val._returnval)


   def createSharedFolder(self, _arg_name, _arg_hostPath, _arg_writable, _arg_automount):
       req=IMachine_createSharedFolderRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       req._hostPath=_arg_hostPath
       req._writable=_arg_writable
       req._automount=_arg_automount
       val=self.mgr.getPort().IMachine_createSharedFolder(req)
       
       return 


   def removeSharedFolder(self, _arg_name):
       req=IMachine_removeSharedFolderRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       val=self.mgr.getPort().IMachine_removeSharedFolder(req)
       
       return 


   def canShowConsoleWindow(self):
       req=IMachine_canShowConsoleWindowRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IMachine_canShowConsoleWindow(req)
       
       return Boolean(self.mgr,val._returnval)


   def showConsoleWindow(self):
       req=IMachine_showConsoleWindowRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IMachine_showConsoleWindow(req)
       
       return Long(self.mgr,val._returnval)


   def getGuestProperty(self, _arg_name):
       req=IMachine_getGuestPropertyRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       val=self.mgr.getPort().IMachine_getGuestProperty(req)
       
       return String(self.mgr,val._value), Long(self.mgr,val._timestamp), String(self.mgr,val._flags)


   def getGuestPropertyValue(self, _arg_property):
       req=IMachine_getGuestPropertyValueRequestMsg()
       req._this=self.handle
       
       req._property=_arg_property
       val=self.mgr.getPort().IMachine_getGuestPropertyValue(req)
       
       return String(self.mgr,val._returnval)


   def getGuestPropertyTimestamp(self, _arg_property):
       req=IMachine_getGuestPropertyTimestampRequestMsg()
       req._this=self.handle
       
       req._property=_arg_property
       val=self.mgr.getPort().IMachine_getGuestPropertyTimestamp(req)
       
       return Long(self.mgr,val._returnval)


   def setGuestProperty(self, _arg_property, _arg_value, _arg_flags):
       req=IMachine_setGuestPropertyRequestMsg()
       req._this=self.handle
       
       req._property=_arg_property
       req._value=_arg_value
       req._flags=_arg_flags
       val=self.mgr.getPort().IMachine_setGuestProperty(req)
       
       return 


   def setGuestPropertyValue(self, _arg_property, _arg_value):
       req=IMachine_setGuestPropertyValueRequestMsg()
       req._this=self.handle
       
       req._property=_arg_property
       req._value=_arg_value
       val=self.mgr.getPort().IMachine_setGuestPropertyValue(req)
       
       return 


   def enumerateGuestProperties(self, _arg_patterns):
       req=IMachine_enumerateGuestPropertiesRequestMsg()
       req._this=self.handle
       
       req._patterns=_arg_patterns
       val=self.mgr.getPort().IMachine_enumerateGuestProperties(req)
       
       return String(self.mgr,val._name, True), String(self.mgr,val._value, True), Long(self.mgr,val._timestamp, True), String(self.mgr,val._flags, True)


   def querySavedGuestSize(self, _arg_screenId):
       req=IMachine_querySavedGuestSizeRequestMsg()
       req._this=self.handle
       
       req._screenId=_arg_screenId
       val=self.mgr.getPort().IMachine_querySavedGuestSize(req)
       
       return UnsignedInt(self.mgr,val._width), UnsignedInt(self.mgr,val._height)


   def querySavedThumbnailSize(self, _arg_screenId):
       req=IMachine_querySavedThumbnailSizeRequestMsg()
       req._this=self.handle
       
       req._screenId=_arg_screenId
       val=self.mgr.getPort().IMachine_querySavedThumbnailSize(req)
       
       return UnsignedInt(self.mgr,val._size), UnsignedInt(self.mgr,val._width), UnsignedInt(self.mgr,val._height)


   def readSavedThumbnailToArray(self, _arg_screenId, _arg_BGR):
       req=IMachine_readSavedThumbnailToArrayRequestMsg()
       req._this=self.handle
       
       req._screenId=_arg_screenId
       req._BGR=_arg_BGR
       val=self.mgr.getPort().IMachine_readSavedThumbnailToArray(req)
       
       return self.mgr.decodebase64(val._returnval), UnsignedInt(self.mgr,val._width), UnsignedInt(self.mgr,val._height)


   def readSavedThumbnailPNGToArray(self, _arg_screenId):
       req=IMachine_readSavedThumbnailPNGToArrayRequestMsg()
       req._this=self.handle
       
       req._screenId=_arg_screenId
       val=self.mgr.getPort().IMachine_readSavedThumbnailPNGToArray(req)
       
       return self.mgr.decodebase64(val._returnval), UnsignedInt(self.mgr,val._width), UnsignedInt(self.mgr,val._height)


   def querySavedScreenshotPNGSize(self, _arg_screenId):
       req=IMachine_querySavedScreenshotPNGSizeRequestMsg()
       req._this=self.handle
       
       req._screenId=_arg_screenId
       val=self.mgr.getPort().IMachine_querySavedScreenshotPNGSize(req)
       
       return UnsignedInt(self.mgr,val._size), UnsignedInt(self.mgr,val._width), UnsignedInt(self.mgr,val._height)


   def readSavedScreenshotPNGToArray(self, _arg_screenId):
       req=IMachine_readSavedScreenshotPNGToArrayRequestMsg()
       req._this=self.handle
       
       req._screenId=_arg_screenId
       val=self.mgr.getPort().IMachine_readSavedScreenshotPNGToArray(req)
       
       return self.mgr.decodebase64(val._returnval), UnsignedInt(self.mgr,val._width), UnsignedInt(self.mgr,val._height)


   def hotPlugCPU(self, _arg_cpu):
       req=IMachine_hotPlugCPURequestMsg()
       req._this=self.handle
       
       req._cpu=_arg_cpu
       val=self.mgr.getPort().IMachine_hotPlugCPU(req)
       
       return 


   def hotUnplugCPU(self, _arg_cpu):
       req=IMachine_hotUnplugCPURequestMsg()
       req._this=self.handle
       
       req._cpu=_arg_cpu
       val=self.mgr.getPort().IMachine_hotUnplugCPU(req)
       
       return 


   def getCPUStatus(self, _arg_cpu):
       req=IMachine_getCPUStatusRequestMsg()
       req._this=self.handle
       
       req._cpu=_arg_cpu
       val=self.mgr.getPort().IMachine_getCPUStatus(req)
       
       return Boolean(self.mgr,val._returnval)


   def queryLogFilename(self, _arg_idx):
       req=IMachine_queryLogFilenameRequestMsg()
       req._this=self.handle
       
       req._idx=_arg_idx
       val=self.mgr.getPort().IMachine_queryLogFilename(req)
       
       return String(self.mgr,val._returnval)


   def readLog(self, _arg_idx, _arg_offset, _arg_size):
       req=IMachine_readLogRequestMsg()
       req._this=self.handle
       
       req._idx=_arg_idx
       req._offset=_arg_offset
       req._size=_arg_size
       val=self.mgr.getPort().IMachine_readLog(req)
       
       return self.mgr.decodebase64(val._returnval)


   def cloneTo(self, _arg_target, _arg_mode, _arg_options):
       req=IMachine_cloneToRequestMsg()
       req._this=self.handle
       
       req._target=_arg_target
       req._mode=_arg_mode
       req._options=_arg_options
       val=self.mgr.getPort().IMachine_cloneTo(req)
       
       return IProgress(self.mgr,val._returnval)


   def getParent(self):
       req=IMachine_getParentRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getParent(req)
       return  IVirtualBox(self.mgr,val._returnval)
   def getAccessible(self):
       req=IMachine_getAccessibleRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getAccessible(req)
       return  Boolean(self.mgr,val._returnval)
   def getAccessError(self):
       req=IMachine_getAccessErrorRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getAccessError(req)
       return  IVirtualBoxErrorInfo(self.mgr,val._returnval)
   def getName(self):
       req=IMachine_getNameRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getName(req)
       return  String(self.mgr,val._returnval)
   def setName(self, value):
       req=IMachine_setNameRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._name = value
       else:
            req._name = value.handle
       self.mgr.getPort().IMachine_setName(req)

   def getDescription(self):
       req=IMachine_getDescriptionRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getDescription(req)
       return  String(self.mgr,val._returnval)
   def setDescription(self, value):
       req=IMachine_setDescriptionRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._description = value
       else:
            req._description = value.handle
       self.mgr.getPort().IMachine_setDescription(req)

   def getId(self):
       req=IMachine_getIdRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getId(req)
       return  String(self.mgr,val._returnval)
   def getOSTypeId(self):
       req=IMachine_getOSTypeIdRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getOSTypeId(req)
       return  String(self.mgr,val._returnval)
   def setOSTypeId(self, value):
       req=IMachine_setOSTypeIdRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._OSTypeId = value
       else:
            req._OSTypeId = value.handle
       self.mgr.getPort().IMachine_setOSTypeId(req)

   def getHardwareVersion(self):
       req=IMachine_getHardwareVersionRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getHardwareVersion(req)
       return  String(self.mgr,val._returnval)
   def setHardwareVersion(self, value):
       req=IMachine_setHardwareVersionRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._hardwareVersion = value
       else:
            req._hardwareVersion = value.handle
       self.mgr.getPort().IMachine_setHardwareVersion(req)

   def getHardwareUUID(self):
       req=IMachine_getHardwareUUIDRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getHardwareUUID(req)
       return  String(self.mgr,val._returnval)
   def setHardwareUUID(self, value):
       req=IMachine_setHardwareUUIDRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._hardwareUUID = value
       else:
            req._hardwareUUID = value.handle
       self.mgr.getPort().IMachine_setHardwareUUID(req)

   def getCPUCount(self):
       req=IMachine_getCPUCountRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getCPUCount(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def setCPUCount(self, value):
       req=IMachine_setCPUCountRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._CPUCount = value
       else:
            req._CPUCount = value.handle
       self.mgr.getPort().IMachine_setCPUCount(req)

   def getCPUHotPlugEnabled(self):
       req=IMachine_getCPUHotPlugEnabledRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getCPUHotPlugEnabled(req)
       return  Boolean(self.mgr,val._returnval)
   def setCPUHotPlugEnabled(self, value):
       req=IMachine_setCPUHotPlugEnabledRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._CPUHotPlugEnabled = value
       else:
            req._CPUHotPlugEnabled = value.handle
       self.mgr.getPort().IMachine_setCPUHotPlugEnabled(req)

   def getCPUExecutionCap(self):
       req=IMachine_getCPUExecutionCapRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getCPUExecutionCap(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def setCPUExecutionCap(self, value):
       req=IMachine_setCPUExecutionCapRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._CPUExecutionCap = value
       else:
            req._CPUExecutionCap = value.handle
       self.mgr.getPort().IMachine_setCPUExecutionCap(req)

   def getMemorySize(self):
       req=IMachine_getMemorySizeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getMemorySize(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def setMemorySize(self, value):
       req=IMachine_setMemorySizeRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._memorySize = value
       else:
            req._memorySize = value.handle
       self.mgr.getPort().IMachine_setMemorySize(req)

   def getMemoryBalloonSize(self):
       req=IMachine_getMemoryBalloonSizeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getMemoryBalloonSize(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def setMemoryBalloonSize(self, value):
       req=IMachine_setMemoryBalloonSizeRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._memoryBalloonSize = value
       else:
            req._memoryBalloonSize = value.handle
       self.mgr.getPort().IMachine_setMemoryBalloonSize(req)

   def getPageFusionEnabled(self):
       req=IMachine_getPageFusionEnabledRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getPageFusionEnabled(req)
       return  Boolean(self.mgr,val._returnval)
   def setPageFusionEnabled(self, value):
       req=IMachine_setPageFusionEnabledRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._pageFusionEnabled = value
       else:
            req._pageFusionEnabled = value.handle
       self.mgr.getPort().IMachine_setPageFusionEnabled(req)

   def getVRAMSize(self):
       req=IMachine_getVRAMSizeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getVRAMSize(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def setVRAMSize(self, value):
       req=IMachine_setVRAMSizeRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._VRAMSize = value
       else:
            req._VRAMSize = value.handle
       self.mgr.getPort().IMachine_setVRAMSize(req)

   def getAccelerate3DEnabled(self):
       req=IMachine_getAccelerate3DEnabledRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getAccelerate3DEnabled(req)
       return  Boolean(self.mgr,val._returnval)
   def setAccelerate3DEnabled(self, value):
       req=IMachine_setAccelerate3DEnabledRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._accelerate3DEnabled = value
       else:
            req._accelerate3DEnabled = value.handle
       self.mgr.getPort().IMachine_setAccelerate3DEnabled(req)

   def getAccelerate2DVideoEnabled(self):
       req=IMachine_getAccelerate2DVideoEnabledRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getAccelerate2DVideoEnabled(req)
       return  Boolean(self.mgr,val._returnval)
   def setAccelerate2DVideoEnabled(self, value):
       req=IMachine_setAccelerate2DVideoEnabledRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._accelerate2DVideoEnabled = value
       else:
            req._accelerate2DVideoEnabled = value.handle
       self.mgr.getPort().IMachine_setAccelerate2DVideoEnabled(req)

   def getMonitorCount(self):
       req=IMachine_getMonitorCountRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getMonitorCount(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def setMonitorCount(self, value):
       req=IMachine_setMonitorCountRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._monitorCount = value
       else:
            req._monitorCount = value.handle
       self.mgr.getPort().IMachine_setMonitorCount(req)

   def getBIOSSettings(self):
       req=IMachine_getBIOSSettingsRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getBIOSSettings(req)
       return  IBIOSSettings(self.mgr,val._returnval)
   def getFirmwareType(self):
       req=IMachine_getFirmwareTypeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getFirmwareType(req)
       return  FirmwareType(self.mgr,val._returnval)
   def setFirmwareType(self, value):
       req=IMachine_setFirmwareTypeRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._firmwareType = value
       else:
            req._firmwareType = value.handle
       self.mgr.getPort().IMachine_setFirmwareType(req)

   def getPointingHidType(self):
       req=IMachine_getPointingHidTypeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getPointingHidType(req)
       return  PointingHidType(self.mgr,val._returnval)
   def setPointingHidType(self, value):
       req=IMachine_setPointingHidTypeRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._pointingHidType = value
       else:
            req._pointingHidType = value.handle
       self.mgr.getPort().IMachine_setPointingHidType(req)

   def getKeyboardHidType(self):
       req=IMachine_getKeyboardHidTypeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getKeyboardHidType(req)
       return  KeyboardHidType(self.mgr,val._returnval)
   def setKeyboardHidType(self, value):
       req=IMachine_setKeyboardHidTypeRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._keyboardHidType = value
       else:
            req._keyboardHidType = value.handle
       self.mgr.getPort().IMachine_setKeyboardHidType(req)

   def getHpetEnabled(self):
       req=IMachine_getHpetEnabledRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getHpetEnabled(req)
       return  Boolean(self.mgr,val._returnval)
   def setHpetEnabled(self, value):
       req=IMachine_setHpetEnabledRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._hpetEnabled = value
       else:
            req._hpetEnabled = value.handle
       self.mgr.getPort().IMachine_setHpetEnabled(req)

   def getChipsetType(self):
       req=IMachine_getChipsetTypeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getChipsetType(req)
       return  ChipsetType(self.mgr,val._returnval)
   def setChipsetType(self, value):
       req=IMachine_setChipsetTypeRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._chipsetType = value
       else:
            req._chipsetType = value.handle
       self.mgr.getPort().IMachine_setChipsetType(req)

   def getSnapshotFolder(self):
       req=IMachine_getSnapshotFolderRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getSnapshotFolder(req)
       return  String(self.mgr,val._returnval)
   def setSnapshotFolder(self, value):
       req=IMachine_setSnapshotFolderRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._snapshotFolder = value
       else:
            req._snapshotFolder = value.handle
       self.mgr.getPort().IMachine_setSnapshotFolder(req)

   def getVRDEServer(self):
       req=IMachine_getVRDEServerRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getVRDEServer(req)
       return  IVRDEServer(self.mgr,val._returnval)
   def getEmulatedUSBWebcameraEnabled(self):
       req=IMachine_getEmulatedUSBWebcameraEnabledRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getEmulatedUSBWebcameraEnabled(req)
       return  Boolean(self.mgr,val._returnval)
   def setEmulatedUSBWebcameraEnabled(self, value):
       req=IMachine_setEmulatedUSBWebcameraEnabledRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._emulatedUSBWebcameraEnabled = value
       else:
            req._emulatedUSBWebcameraEnabled = value.handle
       self.mgr.getPort().IMachine_setEmulatedUSBWebcameraEnabled(req)

   def getEmulatedUSBCardReaderEnabled(self):
       req=IMachine_getEmulatedUSBCardReaderEnabledRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getEmulatedUSBCardReaderEnabled(req)
       return  Boolean(self.mgr,val._returnval)
   def setEmulatedUSBCardReaderEnabled(self, value):
       req=IMachine_setEmulatedUSBCardReaderEnabledRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._emulatedUSBCardReaderEnabled = value
       else:
            req._emulatedUSBCardReaderEnabled = value.handle
       self.mgr.getPort().IMachine_setEmulatedUSBCardReaderEnabled(req)

   def getMediumAttachments(self):
       req=IMachine_getMediumAttachmentsRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getMediumAttachments(req)
       return  IMediumAttachment(self.mgr,val._returnval, True)
   def getUSBController(self):
       req=IMachine_getUSBControllerRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getUSBController(req)
       return  IUSBController(self.mgr,val._returnval)
   def getAudioAdapter(self):
       req=IMachine_getAudioAdapterRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getAudioAdapter(req)
       return  IAudioAdapter(self.mgr,val._returnval)
   def getStorageControllers(self):
       req=IMachine_getStorageControllersRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getStorageControllers(req)
       return  IStorageController(self.mgr,val._returnval, True)
   def getSettingsFilePath(self):
       req=IMachine_getSettingsFilePathRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getSettingsFilePath(req)
       return  String(self.mgr,val._returnval)
   def getSettingsModified(self):
       req=IMachine_getSettingsModifiedRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getSettingsModified(req)
       return  Boolean(self.mgr,val._returnval)
   def getSessionState(self):
       req=IMachine_getSessionStateRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getSessionState(req)
       return  SessionState(self.mgr,val._returnval)
   def getSessionType(self):
       req=IMachine_getSessionTypeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getSessionType(req)
       return  String(self.mgr,val._returnval)
   def getSessionPid(self):
       req=IMachine_getSessionPidRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getSessionPid(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getState(self):
       req=IMachine_getStateRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getState(req)
       return  MachineState(self.mgr,val._returnval)
   def getLastStateChange(self):
       req=IMachine_getLastStateChangeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getLastStateChange(req)
       return  Long(self.mgr,val._returnval)
   def getStateFilePath(self):
       req=IMachine_getStateFilePathRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getStateFilePath(req)
       return  String(self.mgr,val._returnval)
   def getLogFolder(self):
       req=IMachine_getLogFolderRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getLogFolder(req)
       return  String(self.mgr,val._returnval)
   def getCurrentSnapshot(self):
       req=IMachine_getCurrentSnapshotRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getCurrentSnapshot(req)
       return  ISnapshot(self.mgr,val._returnval)
   def getSnapshotCount(self):
       req=IMachine_getSnapshotCountRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getSnapshotCount(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getCurrentStateModified(self):
       req=IMachine_getCurrentStateModifiedRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getCurrentStateModified(req)
       return  Boolean(self.mgr,val._returnval)
   def getSharedFolders(self):
       req=IMachine_getSharedFoldersRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getSharedFolders(req)
       return  ISharedFolder(self.mgr,val._returnval, True)
   def getClipboardMode(self):
       req=IMachine_getClipboardModeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getClipboardMode(req)
       return  ClipboardMode(self.mgr,val._returnval)
   def setClipboardMode(self, value):
       req=IMachine_setClipboardModeRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._clipboardMode = value
       else:
            req._clipboardMode = value.handle
       self.mgr.getPort().IMachine_setClipboardMode(req)

   def getGuestPropertyNotificationPatterns(self):
       req=IMachine_getGuestPropertyNotificationPatternsRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getGuestPropertyNotificationPatterns(req)
       return  String(self.mgr,val._returnval)
   def setGuestPropertyNotificationPatterns(self, value):
       req=IMachine_setGuestPropertyNotificationPatternsRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._guestPropertyNotificationPatterns = value
       else:
            req._guestPropertyNotificationPatterns = value.handle
       self.mgr.getPort().IMachine_setGuestPropertyNotificationPatterns(req)

   def getTeleporterEnabled(self):
       req=IMachine_getTeleporterEnabledRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getTeleporterEnabled(req)
       return  Boolean(self.mgr,val._returnval)
   def setTeleporterEnabled(self, value):
       req=IMachine_setTeleporterEnabledRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._teleporterEnabled = value
       else:
            req._teleporterEnabled = value.handle
       self.mgr.getPort().IMachine_setTeleporterEnabled(req)

   def getTeleporterPort(self):
       req=IMachine_getTeleporterPortRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getTeleporterPort(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def setTeleporterPort(self, value):
       req=IMachine_setTeleporterPortRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._teleporterPort = value
       else:
            req._teleporterPort = value.handle
       self.mgr.getPort().IMachine_setTeleporterPort(req)

   def getTeleporterAddress(self):
       req=IMachine_getTeleporterAddressRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getTeleporterAddress(req)
       return  String(self.mgr,val._returnval)
   def setTeleporterAddress(self, value):
       req=IMachine_setTeleporterAddressRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._teleporterAddress = value
       else:
            req._teleporterAddress = value.handle
       self.mgr.getPort().IMachine_setTeleporterAddress(req)

   def getTeleporterPassword(self):
       req=IMachine_getTeleporterPasswordRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getTeleporterPassword(req)
       return  String(self.mgr,val._returnval)
   def setTeleporterPassword(self, value):
       req=IMachine_setTeleporterPasswordRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._teleporterPassword = value
       else:
            req._teleporterPassword = value.handle
       self.mgr.getPort().IMachine_setTeleporterPassword(req)

   def getFaultToleranceState(self):
       req=IMachine_getFaultToleranceStateRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getFaultToleranceState(req)
       return  FaultToleranceState(self.mgr,val._returnval)
   def setFaultToleranceState(self, value):
       req=IMachine_setFaultToleranceStateRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._faultToleranceState = value
       else:
            req._faultToleranceState = value.handle
       self.mgr.getPort().IMachine_setFaultToleranceState(req)

   def getFaultTolerancePort(self):
       req=IMachine_getFaultTolerancePortRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getFaultTolerancePort(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def setFaultTolerancePort(self, value):
       req=IMachine_setFaultTolerancePortRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._faultTolerancePort = value
       else:
            req._faultTolerancePort = value.handle
       self.mgr.getPort().IMachine_setFaultTolerancePort(req)

   def getFaultToleranceAddress(self):
       req=IMachine_getFaultToleranceAddressRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getFaultToleranceAddress(req)
       return  String(self.mgr,val._returnval)
   def setFaultToleranceAddress(self, value):
       req=IMachine_setFaultToleranceAddressRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._faultToleranceAddress = value
       else:
            req._faultToleranceAddress = value.handle
       self.mgr.getPort().IMachine_setFaultToleranceAddress(req)

   def getFaultTolerancePassword(self):
       req=IMachine_getFaultTolerancePasswordRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getFaultTolerancePassword(req)
       return  String(self.mgr,val._returnval)
   def setFaultTolerancePassword(self, value):
       req=IMachine_setFaultTolerancePasswordRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._faultTolerancePassword = value
       else:
            req._faultTolerancePassword = value.handle
       self.mgr.getPort().IMachine_setFaultTolerancePassword(req)

   def getFaultToleranceSyncInterval(self):
       req=IMachine_getFaultToleranceSyncIntervalRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getFaultToleranceSyncInterval(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def setFaultToleranceSyncInterval(self, value):
       req=IMachine_setFaultToleranceSyncIntervalRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._faultToleranceSyncInterval = value
       else:
            req._faultToleranceSyncInterval = value.handle
       self.mgr.getPort().IMachine_setFaultToleranceSyncInterval(req)

   def getRTCUseUTC(self):
       req=IMachine_getRTCUseUTCRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getRTCUseUTC(req)
       return  Boolean(self.mgr,val._returnval)
   def setRTCUseUTC(self, value):
       req=IMachine_setRTCUseUTCRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._RTCUseUTC = value
       else:
            req._RTCUseUTC = value.handle
       self.mgr.getPort().IMachine_setRTCUseUTC(req)

   def getIoCacheEnabled(self):
       req=IMachine_getIoCacheEnabledRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getIoCacheEnabled(req)
       return  Boolean(self.mgr,val._returnval)
   def setIoCacheEnabled(self, value):
       req=IMachine_setIoCacheEnabledRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._ioCacheEnabled = value
       else:
            req._ioCacheEnabled = value.handle
       self.mgr.getPort().IMachine_setIoCacheEnabled(req)

   def getIoCacheSize(self):
       req=IMachine_getIoCacheSizeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getIoCacheSize(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def setIoCacheSize(self, value):
       req=IMachine_setIoCacheSizeRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._ioCacheSize = value
       else:
            req._ioCacheSize = value.handle
       self.mgr.getPort().IMachine_setIoCacheSize(req)

   def getBandwidthControl(self):
       req=IMachine_getBandwidthControlRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getBandwidthControl(req)
       return  IBandwidthControl(self.mgr,val._returnval)
   def getPciDeviceAssignments(self):
       req=IMachine_getPciDeviceAssignmentsRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachine_getPciDeviceAssignments(req)
       return  IPciDeviceAttachment(self.mgr,val._returnval, True)


   _Attrs_={         'parent':[getParent,None],
         'accessible':[getAccessible,None],
         'accessError':[getAccessError,None],
         'name':[getName,setName,
        ],
         'description':[getDescription,setDescription,
        ],
         'id':[getId,None],
         'OSTypeId':[getOSTypeId,setOSTypeId,
        ],
         'hardwareVersion':[getHardwareVersion,setHardwareVersion,
        ],
         'hardwareUUID':[getHardwareUUID,setHardwareUUID,
        ],
         'CPUCount':[getCPUCount,setCPUCount,
        ],
         'CPUHotPlugEnabled':[getCPUHotPlugEnabled,setCPUHotPlugEnabled,
        ],
         'CPUExecutionCap':[getCPUExecutionCap,setCPUExecutionCap,
        ],
         'memorySize':[getMemorySize,setMemorySize,
        ],
         'memoryBalloonSize':[getMemoryBalloonSize,setMemoryBalloonSize,
        ],
         'pageFusionEnabled':[getPageFusionEnabled,setPageFusionEnabled,
        ],
         'VRAMSize':[getVRAMSize,setVRAMSize,
        ],
         'accelerate3DEnabled':[getAccelerate3DEnabled,setAccelerate3DEnabled,
        ],
         'accelerate2DVideoEnabled':[getAccelerate2DVideoEnabled,setAccelerate2DVideoEnabled,
        ],
         'monitorCount':[getMonitorCount,setMonitorCount,
        ],
         'BIOSSettings':[getBIOSSettings,None],
         'firmwareType':[getFirmwareType,setFirmwareType,
        ],
         'pointingHidType':[getPointingHidType,setPointingHidType,
        ],
         'keyboardHidType':[getKeyboardHidType,setKeyboardHidType,
        ],
         'hpetEnabled':[getHpetEnabled,setHpetEnabled,
        ],
         'chipsetType':[getChipsetType,setChipsetType,
        ],
         'snapshotFolder':[getSnapshotFolder,setSnapshotFolder,
        ],
         'VRDEServer':[getVRDEServer,None],
         'emulatedUSBWebcameraEnabled':[getEmulatedUSBWebcameraEnabled,setEmulatedUSBWebcameraEnabled,
        ],
         'emulatedUSBCardReaderEnabled':[getEmulatedUSBCardReaderEnabled,setEmulatedUSBCardReaderEnabled,
        ],
         'mediumAttachments':[getMediumAttachments,None],
         'USBController':[getUSBController,None],
         'audioAdapter':[getAudioAdapter,None],
         'storageControllers':[getStorageControllers,None],
         'settingsFilePath':[getSettingsFilePath,None],
         'settingsModified':[getSettingsModified,None],
         'sessionState':[getSessionState,None],
         'sessionType':[getSessionType,None],
         'sessionPid':[getSessionPid,None],
         'state':[getState,None],
         'lastStateChange':[getLastStateChange,None],
         'stateFilePath':[getStateFilePath,None],
         'logFolder':[getLogFolder,None],
         'currentSnapshot':[getCurrentSnapshot,None],
         'snapshotCount':[getSnapshotCount,None],
         'currentStateModified':[getCurrentStateModified,None],
         'sharedFolders':[getSharedFolders,None],
         'clipboardMode':[getClipboardMode,setClipboardMode,
        ],
         'guestPropertyNotificationPatterns':[getGuestPropertyNotificationPatterns,setGuestPropertyNotificationPatterns,
        ],
         'teleporterEnabled':[getTeleporterEnabled,setTeleporterEnabled,
        ],
         'teleporterPort':[getTeleporterPort,setTeleporterPort,
        ],
         'teleporterAddress':[getTeleporterAddress,setTeleporterAddress,
        ],
         'teleporterPassword':[getTeleporterPassword,setTeleporterPassword,
        ],
         'faultToleranceState':[getFaultToleranceState,setFaultToleranceState,
        ],
         'faultTolerancePort':[getFaultTolerancePort,setFaultTolerancePort,
        ],
         'faultToleranceAddress':[getFaultToleranceAddress,setFaultToleranceAddress,
        ],
         'faultTolerancePassword':[getFaultTolerancePassword,setFaultTolerancePassword,
        ],
         'faultToleranceSyncInterval':[getFaultToleranceSyncInterval,setFaultToleranceSyncInterval,
        ],
         'RTCUseUTC':[getRTCUseUTC,setRTCUseUTC,
        ],
         'ioCacheEnabled':[getIoCacheEnabled,setIoCacheEnabled,
        ],
         'ioCacheSize':[getIoCacheSize,setIoCacheSize,
        ],
         'bandwidthControl':[getBandwidthControl,None],
         'pciDeviceAssignments':[getPciDeviceAssignments,None]}

class IConsole(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IConsole(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IConsole._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IConsole._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def powerUp(self):
       req=IConsole_powerUpRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IConsole_powerUp(req)
       
       return IProgress(self.mgr,val._returnval)


   def powerUpPaused(self):
       req=IConsole_powerUpPausedRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IConsole_powerUpPaused(req)
       
       return IProgress(self.mgr,val._returnval)


   def powerDown(self):
       req=IConsole_powerDownRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IConsole_powerDown(req)
       
       return IProgress(self.mgr,val._returnval)


   def reset(self):
       req=IConsole_resetRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IConsole_reset(req)
       
       return 


   def pause(self):
       req=IConsole_pauseRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IConsole_pause(req)
       
       return 


   def resume(self):
       req=IConsole_resumeRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IConsole_resume(req)
       
       return 


   def powerButton(self):
       req=IConsole_powerButtonRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IConsole_powerButton(req)
       
       return 


   def sleepButton(self):
       req=IConsole_sleepButtonRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IConsole_sleepButton(req)
       
       return 


   def getPowerButtonHandled(self):
       req=IConsole_getPowerButtonHandledRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IConsole_getPowerButtonHandled(req)
       
       return Boolean(self.mgr,val._returnval)


   def getGuestEnteredACPIMode(self):
       req=IConsole_getGuestEnteredACPIModeRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IConsole_getGuestEnteredACPIMode(req)
       
       return Boolean(self.mgr,val._returnval)


   def saveState(self):
       req=IConsole_saveStateRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IConsole_saveState(req)
       
       return IProgress(self.mgr,val._returnval)


   def adoptSavedState(self, _arg_savedStateFile):
       req=IConsole_adoptSavedStateRequestMsg()
       req._this=self.handle
       
       req._savedStateFile=_arg_savedStateFile
       val=self.mgr.getPort().IConsole_adoptSavedState(req)
       
       return 


   def discardSavedState(self, _arg_fRemoveFile):
       req=IConsole_discardSavedStateRequestMsg()
       req._this=self.handle
       
       req._fRemoveFile=_arg_fRemoveFile
       val=self.mgr.getPort().IConsole_discardSavedState(req)
       
       return 


   def getDeviceActivity(self, _arg_type):
       req=IConsole_getDeviceActivityRequestMsg()
       req._this=self.handle
       
       req._type=_arg_type
       val=self.mgr.getPort().IConsole_getDeviceActivity(req)
       
       return DeviceActivity(self.mgr,val._returnval)


   def attachUSBDevice(self, _arg_id):
       req=IConsole_attachUSBDeviceRequestMsg()
       req._this=self.handle
       
       req._id=_arg_id
       val=self.mgr.getPort().IConsole_attachUSBDevice(req)
       
       return 


   def detachUSBDevice(self, _arg_id):
       req=IConsole_detachUSBDeviceRequestMsg()
       req._this=self.handle
       
       req._id=_arg_id
       val=self.mgr.getPort().IConsole_detachUSBDevice(req)
       
       return IUSBDevice(self.mgr,val._returnval)


   def findUSBDeviceByAddress(self, _arg_name):
       req=IConsole_findUSBDeviceByAddressRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       val=self.mgr.getPort().IConsole_findUSBDeviceByAddress(req)
       
       return IUSBDevice(self.mgr,val._returnval)


   def findUSBDeviceById(self, _arg_id):
       req=IConsole_findUSBDeviceByIdRequestMsg()
       req._this=self.handle
       
       req._id=_arg_id
       val=self.mgr.getPort().IConsole_findUSBDeviceById(req)
       
       return IUSBDevice(self.mgr,val._returnval)


   def createSharedFolder(self, _arg_name, _arg_hostPath, _arg_writable, _arg_automount):
       req=IConsole_createSharedFolderRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       req._hostPath=_arg_hostPath
       req._writable=_arg_writable
       req._automount=_arg_automount
       val=self.mgr.getPort().IConsole_createSharedFolder(req)
       
       return 


   def removeSharedFolder(self, _arg_name):
       req=IConsole_removeSharedFolderRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       val=self.mgr.getPort().IConsole_removeSharedFolder(req)
       
       return 


   def takeSnapshot(self, _arg_name, _arg_description):
       req=IConsole_takeSnapshotRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       req._description=_arg_description
       val=self.mgr.getPort().IConsole_takeSnapshot(req)
       
       return IProgress(self.mgr,val._returnval)


   def deleteSnapshot(self, _arg_id):
       req=IConsole_deleteSnapshotRequestMsg()
       req._this=self.handle
       
       req._id=_arg_id
       val=self.mgr.getPort().IConsole_deleteSnapshot(req)
       
       return IProgress(self.mgr,val._returnval)


   def deleteSnapshotAndAllChildren(self, _arg_id):
       req=IConsole_deleteSnapshotAndAllChildrenRequestMsg()
       req._this=self.handle
       
       req._id=_arg_id
       val=self.mgr.getPort().IConsole_deleteSnapshotAndAllChildren(req)
       
       return IProgress(self.mgr,val._returnval)


   def deleteSnapshotRange(self, _arg_startId, _arg_endId):
       req=IConsole_deleteSnapshotRangeRequestMsg()
       req._this=self.handle
       
       req._startId=_arg_startId
       req._endId=_arg_endId
       val=self.mgr.getPort().IConsole_deleteSnapshotRange(req)
       
       return IProgress(self.mgr,val._returnval)


   def restoreSnapshot(self, _arg_snapshot):
       req=IConsole_restoreSnapshotRequestMsg()
       req._this=self.handle
       
       req._snapshot=_arg_snapshot
       val=self.mgr.getPort().IConsole_restoreSnapshot(req)
       
       return IProgress(self.mgr,val._returnval)


   def teleport(self, _arg_hostname, _arg_tcpport, _arg_password, _arg_maxDowntime):
       req=IConsole_teleportRequestMsg()
       req._this=self.handle
       
       req._hostname=_arg_hostname
       req._tcpport=_arg_tcpport
       req._password=_arg_password
       req._maxDowntime=_arg_maxDowntime
       val=self.mgr.getPort().IConsole_teleport(req)
       
       return IProgress(self.mgr,val._returnval)


   def getMachine(self):
       req=IConsole_getMachineRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IConsole_getMachine(req)
       return  IMachine(self.mgr,val._returnval)
   def getState(self):
       req=IConsole_getStateRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IConsole_getState(req)
       return  MachineState(self.mgr,val._returnval)
   def getGuest(self):
       req=IConsole_getGuestRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IConsole_getGuest(req)
       return  IGuest(self.mgr,val._returnval)
   def getKeyboard(self):
       req=IConsole_getKeyboardRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IConsole_getKeyboard(req)
       return  IKeyboard(self.mgr,val._returnval)
   def getMouse(self):
       req=IConsole_getMouseRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IConsole_getMouse(req)
       return  IMouse(self.mgr,val._returnval)
   def getDisplay(self):
       req=IConsole_getDisplayRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IConsole_getDisplay(req)
       return  IDisplay(self.mgr,val._returnval)
   def getUSBDevices(self):
       req=IConsole_getUSBDevicesRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IConsole_getUSBDevices(req)
       return  IUSBDevice(self.mgr,val._returnval, True)
   def getRemoteUSBDevices(self):
       req=IConsole_getRemoteUSBDevicesRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IConsole_getRemoteUSBDevices(req)
       return  IHostUSBDevice(self.mgr,val._returnval, True)
   def getSharedFolders(self):
       req=IConsole_getSharedFoldersRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IConsole_getSharedFolders(req)
       return  ISharedFolder(self.mgr,val._returnval, True)
   def getVRDEServerInfo(self):
       req=IConsole_getVRDEServerInfoRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IConsole_getVRDEServerInfo(req)
       return  IVRDEServerInfo(self.mgr,val._returnval)
   def getEventSource(self):
       req=IConsole_getEventSourceRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IConsole_getEventSource(req)
       return  IEventSource(self.mgr,val._returnval)
   def getAttachedPciDevices(self):
       req=IConsole_getAttachedPciDevicesRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IConsole_getAttachedPciDevices(req)
       return  IPciDeviceAttachment(self.mgr,val._returnval, True)
   def getUseHostClipboard(self):
       req=IConsole_getUseHostClipboardRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IConsole_getUseHostClipboard(req)
       return  Boolean(self.mgr,val._returnval)
   def setUseHostClipboard(self, value):
       req=IConsole_setUseHostClipboardRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._useHostClipboard = value
       else:
            req._useHostClipboard = value.handle
       self.mgr.getPort().IConsole_setUseHostClipboard(req)



   _Attrs_={         'machine':[getMachine,None],
         'state':[getState,None],
         'guest':[getGuest,None],
         'keyboard':[getKeyboard,None],
         'mouse':[getMouse,None],
         'display':[getDisplay,None],
         'USBDevices':[getUSBDevices,None],
         'remoteUSBDevices':[getRemoteUSBDevices,None],
         'sharedFolders':[getSharedFolders,None],
         'VRDEServerInfo':[getVRDEServerInfo,None],
         'eventSource':[getEventSource,None],
         'attachedPciDevices':[getAttachedPciDevices,None],
         'useHostClipboard':[getUseHostClipboard,setUseHostClipboard,
        ]}

class IHostNetworkInterface(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IHostNetworkInterface(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IHostNetworkInterface._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IHostNetworkInterface._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def enableStaticIpConfig(self, _arg_IPAddress, _arg_networkMask):
       req=IHostNetworkInterface_enableStaticIpConfigRequestMsg()
       req._this=self.handle
       
       req._IPAddress=_arg_IPAddress
       req._networkMask=_arg_networkMask
       val=self.mgr.getPort().IHostNetworkInterface_enableStaticIpConfig(req)
       
       return 


   def enableStaticIpConfigV6(self, _arg_IPV6Address, _arg_IPV6NetworkMaskPrefixLength):
       req=IHostNetworkInterface_enableStaticIpConfigV6RequestMsg()
       req._this=self.handle
       
       req._IPV6Address=_arg_IPV6Address
       req._IPV6NetworkMaskPrefixLength=_arg_IPV6NetworkMaskPrefixLength
       val=self.mgr.getPort().IHostNetworkInterface_enableStaticIpConfigV6(req)
       
       return 


   def enableDynamicIpConfig(self):
       req=IHostNetworkInterface_enableDynamicIpConfigRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IHostNetworkInterface_enableDynamicIpConfig(req)
       
       return 


   def dhcpRediscover(self):
       req=IHostNetworkInterface_dhcpRediscoverRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IHostNetworkInterface_dhcpRediscover(req)
       
       return 


   def getName(self):
       req=IHostNetworkInterface_getNameRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHostNetworkInterface_getName(req)
       return  String(self.mgr,val._returnval)
   def getId(self):
       req=IHostNetworkInterface_getIdRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHostNetworkInterface_getId(req)
       return  String(self.mgr,val._returnval)
   def getNetworkName(self):
       req=IHostNetworkInterface_getNetworkNameRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHostNetworkInterface_getNetworkName(req)
       return  String(self.mgr,val._returnval)
   def getDhcpEnabled(self):
       req=IHostNetworkInterface_getDhcpEnabledRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHostNetworkInterface_getDhcpEnabled(req)
       return  Boolean(self.mgr,val._returnval)
   def getIPAddress(self):
       req=IHostNetworkInterface_getIPAddressRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHostNetworkInterface_getIPAddress(req)
       return  String(self.mgr,val._returnval)
   def getNetworkMask(self):
       req=IHostNetworkInterface_getNetworkMaskRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHostNetworkInterface_getNetworkMask(req)
       return  String(self.mgr,val._returnval)
   def getIPV6Supported(self):
       req=IHostNetworkInterface_getIPV6SupportedRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHostNetworkInterface_getIPV6Supported(req)
       return  Boolean(self.mgr,val._returnval)
   def getIPV6Address(self):
       req=IHostNetworkInterface_getIPV6AddressRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHostNetworkInterface_getIPV6Address(req)
       return  String(self.mgr,val._returnval)
   def getIPV6NetworkMaskPrefixLength(self):
       req=IHostNetworkInterface_getIPV6NetworkMaskPrefixLengthRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHostNetworkInterface_getIPV6NetworkMaskPrefixLength(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getHardwareAddress(self):
       req=IHostNetworkInterface_getHardwareAddressRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHostNetworkInterface_getHardwareAddress(req)
       return  String(self.mgr,val._returnval)
   def getMediumType(self):
       req=IHostNetworkInterface_getMediumTypeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHostNetworkInterface_getMediumType(req)
       return  HostNetworkInterfaceMediumType(self.mgr,val._returnval)
   def getStatus(self):
       req=IHostNetworkInterface_getStatusRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHostNetworkInterface_getStatus(req)
       return  HostNetworkInterfaceStatus(self.mgr,val._returnval)
   def getInterfaceType(self):
       req=IHostNetworkInterface_getInterfaceTypeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHostNetworkInterface_getInterfaceType(req)
       return  HostNetworkInterfaceType(self.mgr,val._returnval)


   _Attrs_={         'name':[getName,None],
         'id':[getId,None],
         'networkName':[getNetworkName,None],
         'dhcpEnabled':[getDhcpEnabled,None],
         'IPAddress':[getIPAddress,None],
         'networkMask':[getNetworkMask,None],
         'IPV6Supported':[getIPV6Supported,None],
         'IPV6Address':[getIPV6Address,None],
         'IPV6NetworkMaskPrefixLength':[getIPV6NetworkMaskPrefixLength,None],
         'hardwareAddress':[getHardwareAddress,None],
         'mediumType':[getMediumType,None],
         'status':[getStatus,None],
         'interfaceType':[getInterfaceType,None]}

class IHost(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IHost(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IHost._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IHost._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getProcessorSpeed(self, _arg_cpuId):
       req=IHost_getProcessorSpeedRequestMsg()
       req._this=self.handle
       
       req._cpuId=_arg_cpuId
       val=self.mgr.getPort().IHost_getProcessorSpeed(req)
       
       return UnsignedInt(self.mgr,val._returnval)


   def getProcessorFeature(self, _arg_feature):
       req=IHost_getProcessorFeatureRequestMsg()
       req._this=self.handle
       
       req._feature=_arg_feature
       val=self.mgr.getPort().IHost_getProcessorFeature(req)
       
       return Boolean(self.mgr,val._returnval)


   def getProcessorDescription(self, _arg_cpuId):
       req=IHost_getProcessorDescriptionRequestMsg()
       req._this=self.handle
       
       req._cpuId=_arg_cpuId
       val=self.mgr.getPort().IHost_getProcessorDescription(req)
       
       return String(self.mgr,val._returnval)


   def getProcessorCPUIDLeaf(self, _arg_cpuId, _arg_leaf, _arg_subLeaf):
       req=IHost_getProcessorCPUIDLeafRequestMsg()
       req._this=self.handle
       
       req._cpuId=_arg_cpuId
       req._leaf=_arg_leaf
       req._subLeaf=_arg_subLeaf
       val=self.mgr.getPort().IHost_getProcessorCPUIDLeaf(req)
       
       return UnsignedInt(self.mgr,val._valEax), UnsignedInt(self.mgr,val._valEbx), UnsignedInt(self.mgr,val._valEcx), UnsignedInt(self.mgr,val._valEdx)


   def createHostOnlyNetworkInterface(self):
       req=IHost_createHostOnlyNetworkInterfaceRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IHost_createHostOnlyNetworkInterface(req)
       
       return IProgress(self.mgr,val._returnval), IHostNetworkInterface(self.mgr,val._hostInterface)


   def removeHostOnlyNetworkInterface(self, _arg_id):
       req=IHost_removeHostOnlyNetworkInterfaceRequestMsg()
       req._this=self.handle
       
       req._id=_arg_id
       val=self.mgr.getPort().IHost_removeHostOnlyNetworkInterface(req)
       
       return IProgress(self.mgr,val._returnval)


   def createUSBDeviceFilter(self, _arg_name):
       req=IHost_createUSBDeviceFilterRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       val=self.mgr.getPort().IHost_createUSBDeviceFilter(req)
       
       return IHostUSBDeviceFilter(self.mgr,val._returnval)


   def insertUSBDeviceFilter(self, _arg_position, _arg_filter):
       req=IHost_insertUSBDeviceFilterRequestMsg()
       req._this=self.handle
       
       req._position=_arg_position
       req._filter=_arg_filter
       val=self.mgr.getPort().IHost_insertUSBDeviceFilter(req)
       
       return 


   def removeUSBDeviceFilter(self, _arg_position):
       req=IHost_removeUSBDeviceFilterRequestMsg()
       req._this=self.handle
       
       req._position=_arg_position
       val=self.mgr.getPort().IHost_removeUSBDeviceFilter(req)
       
       return 


   def findHostDVDDrive(self, _arg_name):
       req=IHost_findHostDVDDriveRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       val=self.mgr.getPort().IHost_findHostDVDDrive(req)
       
       return IMedium(self.mgr,val._returnval)


   def findHostFloppyDrive(self, _arg_name):
       req=IHost_findHostFloppyDriveRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       val=self.mgr.getPort().IHost_findHostFloppyDrive(req)
       
       return IMedium(self.mgr,val._returnval)


   def findHostNetworkInterfaceByName(self, _arg_name):
       req=IHost_findHostNetworkInterfaceByNameRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       val=self.mgr.getPort().IHost_findHostNetworkInterfaceByName(req)
       
       return IHostNetworkInterface(self.mgr,val._returnval)


   def findHostNetworkInterfaceById(self, _arg_id):
       req=IHost_findHostNetworkInterfaceByIdRequestMsg()
       req._this=self.handle
       
       req._id=_arg_id
       val=self.mgr.getPort().IHost_findHostNetworkInterfaceById(req)
       
       return IHostNetworkInterface(self.mgr,val._returnval)


   def findHostNetworkInterfacesOfType(self, _arg_type):
       req=IHost_findHostNetworkInterfacesOfTypeRequestMsg()
       req._this=self.handle
       
       req._type=_arg_type
       val=self.mgr.getPort().IHost_findHostNetworkInterfacesOfType(req)
       
       return IHostNetworkInterface(self.mgr,val._returnval, True)


   def findUSBDeviceById(self, _arg_id):
       req=IHost_findUSBDeviceByIdRequestMsg()
       req._this=self.handle
       
       req._id=_arg_id
       val=self.mgr.getPort().IHost_findUSBDeviceById(req)
       
       return IHostUSBDevice(self.mgr,val._returnval)


   def findUSBDeviceByAddress(self, _arg_name):
       req=IHost_findUSBDeviceByAddressRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       val=self.mgr.getPort().IHost_findUSBDeviceByAddress(req)
       
       return IHostUSBDevice(self.mgr,val._returnval)


   def generateMACAddress(self):
       req=IHost_generateMACAddressRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IHost_generateMACAddress(req)
       
       return String(self.mgr,val._returnval)


   def getDVDDrives(self):
       req=IHost_getDVDDrivesRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHost_getDVDDrives(req)
       return  IMedium(self.mgr,val._returnval, True)
   def getFloppyDrives(self):
       req=IHost_getFloppyDrivesRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHost_getFloppyDrives(req)
       return  IMedium(self.mgr,val._returnval, True)
   def getUSBDevices(self):
       req=IHost_getUSBDevicesRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHost_getUSBDevices(req)
       return  IHostUSBDevice(self.mgr,val._returnval, True)
   def getUSBDeviceFilters(self):
       req=IHost_getUSBDeviceFiltersRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHost_getUSBDeviceFilters(req)
       return  IHostUSBDeviceFilter(self.mgr,val._returnval, True)
   def getNetworkInterfaces(self):
       req=IHost_getNetworkInterfacesRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHost_getNetworkInterfaces(req)
       return  IHostNetworkInterface(self.mgr,val._returnval, True)
   def getProcessorCount(self):
       req=IHost_getProcessorCountRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHost_getProcessorCount(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getProcessorOnlineCount(self):
       req=IHost_getProcessorOnlineCountRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHost_getProcessorOnlineCount(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getProcessorCoreCount(self):
       req=IHost_getProcessorCoreCountRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHost_getProcessorCoreCount(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getMemorySize(self):
       req=IHost_getMemorySizeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHost_getMemorySize(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getMemoryAvailable(self):
       req=IHost_getMemoryAvailableRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHost_getMemoryAvailable(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getOperatingSystem(self):
       req=IHost_getOperatingSystemRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHost_getOperatingSystem(req)
       return  String(self.mgr,val._returnval)
   def getOSVersion(self):
       req=IHost_getOSVersionRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHost_getOSVersion(req)
       return  String(self.mgr,val._returnval)
   def getUTCTime(self):
       req=IHost_getUTCTimeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHost_getUTCTime(req)
       return  Long(self.mgr,val._returnval)
   def getAcceleration3DAvailable(self):
       req=IHost_getAcceleration3DAvailableRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHost_getAcceleration3DAvailable(req)
       return  Boolean(self.mgr,val._returnval)


   _Attrs_={         'DVDDrives':[getDVDDrives,None],
         'floppyDrives':[getFloppyDrives,None],
         'USBDevices':[getUSBDevices,None],
         'USBDeviceFilters':[getUSBDeviceFilters,None],
         'networkInterfaces':[getNetworkInterfaces,None],
         'processorCount':[getProcessorCount,None],
         'processorOnlineCount':[getProcessorOnlineCount,None],
         'processorCoreCount':[getProcessorCoreCount,None],
         'memorySize':[getMemorySize,None],
         'memoryAvailable':[getMemoryAvailable,None],
         'operatingSystem':[getOperatingSystem,None],
         'OSVersion':[getOSVersion,None],
         'UTCTime':[getUTCTime,None],
         'Acceleration3DAvailable':[getAcceleration3DAvailable,None]}

class ISystemProperties(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return ISystemProperties(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ISystemProperties._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ISystemProperties._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getMaxNetworkAdapters(self, _arg_chipset):
       req=ISystemProperties_getMaxNetworkAdaptersRequestMsg()
       req._this=self.handle
       
       req._chipset=_arg_chipset
       val=self.mgr.getPort().ISystemProperties_getMaxNetworkAdapters(req)
       
       return UnsignedInt(self.mgr,val._returnval)


   def getMaxNetworkAdaptersOfType(self, _arg_chipset, _arg_type):
       req=ISystemProperties_getMaxNetworkAdaptersOfTypeRequestMsg()
       req._this=self.handle
       
       req._chipset=_arg_chipset
       req._type=_arg_type
       val=self.mgr.getPort().ISystemProperties_getMaxNetworkAdaptersOfType(req)
       
       return UnsignedInt(self.mgr,val._returnval)


   def getMaxDevicesPerPortForStorageBus(self, _arg_bus):
       req=ISystemProperties_getMaxDevicesPerPortForStorageBusRequestMsg()
       req._this=self.handle
       
       req._bus=_arg_bus
       val=self.mgr.getPort().ISystemProperties_getMaxDevicesPerPortForStorageBus(req)
       
       return UnsignedInt(self.mgr,val._returnval)


   def getMinPortCountForStorageBus(self, _arg_bus):
       req=ISystemProperties_getMinPortCountForStorageBusRequestMsg()
       req._this=self.handle
       
       req._bus=_arg_bus
       val=self.mgr.getPort().ISystemProperties_getMinPortCountForStorageBus(req)
       
       return UnsignedInt(self.mgr,val._returnval)


   def getMaxPortCountForStorageBus(self, _arg_bus):
       req=ISystemProperties_getMaxPortCountForStorageBusRequestMsg()
       req._this=self.handle
       
       req._bus=_arg_bus
       val=self.mgr.getPort().ISystemProperties_getMaxPortCountForStorageBus(req)
       
       return UnsignedInt(self.mgr,val._returnval)


   def getMaxInstancesOfStorageBus(self, _arg_chipset, _arg_bus):
       req=ISystemProperties_getMaxInstancesOfStorageBusRequestMsg()
       req._this=self.handle
       
       req._chipset=_arg_chipset
       req._bus=_arg_bus
       val=self.mgr.getPort().ISystemProperties_getMaxInstancesOfStorageBus(req)
       
       return UnsignedInt(self.mgr,val._returnval)


   def getDeviceTypesForStorageBus(self, _arg_bus):
       req=ISystemProperties_getDeviceTypesForStorageBusRequestMsg()
       req._this=self.handle
       
       req._bus=_arg_bus
       val=self.mgr.getPort().ISystemProperties_getDeviceTypesForStorageBus(req)
       
       return DeviceType(self.mgr,val._returnval, True)


   def getDefaultIoCacheSettingForStorageController(self, _arg_controllerType):
       req=ISystemProperties_getDefaultIoCacheSettingForStorageControllerRequestMsg()
       req._this=self.handle
       
       req._controllerType=_arg_controllerType
       val=self.mgr.getPort().ISystemProperties_getDefaultIoCacheSettingForStorageController(req)
       
       return Boolean(self.mgr,val._returnval)


   def getMinGuestRAM(self):
       req=ISystemProperties_getMinGuestRAMRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISystemProperties_getMinGuestRAM(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getMaxGuestRAM(self):
       req=ISystemProperties_getMaxGuestRAMRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISystemProperties_getMaxGuestRAM(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getMinGuestVRAM(self):
       req=ISystemProperties_getMinGuestVRAMRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISystemProperties_getMinGuestVRAM(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getMaxGuestVRAM(self):
       req=ISystemProperties_getMaxGuestVRAMRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISystemProperties_getMaxGuestVRAM(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getMinGuestCPUCount(self):
       req=ISystemProperties_getMinGuestCPUCountRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISystemProperties_getMinGuestCPUCount(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getMaxGuestCPUCount(self):
       req=ISystemProperties_getMaxGuestCPUCountRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISystemProperties_getMaxGuestCPUCount(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getMaxGuestMonitors(self):
       req=ISystemProperties_getMaxGuestMonitorsRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISystemProperties_getMaxGuestMonitors(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getInfoVDSize(self):
       req=ISystemProperties_getInfoVDSizeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISystemProperties_getInfoVDSize(req)
       return  Long(self.mgr,val._returnval)
   def getSerialPortCount(self):
       req=ISystemProperties_getSerialPortCountRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISystemProperties_getSerialPortCount(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getParallelPortCount(self):
       req=ISystemProperties_getParallelPortCountRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISystemProperties_getParallelPortCount(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getMaxBootPosition(self):
       req=ISystemProperties_getMaxBootPositionRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISystemProperties_getMaxBootPosition(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getDefaultMachineFolder(self):
       req=ISystemProperties_getDefaultMachineFolderRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISystemProperties_getDefaultMachineFolder(req)
       return  String(self.mgr,val._returnval)
   def setDefaultMachineFolder(self, value):
       req=ISystemProperties_setDefaultMachineFolderRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._defaultMachineFolder = value
       else:
            req._defaultMachineFolder = value.handle
       self.mgr.getPort().ISystemProperties_setDefaultMachineFolder(req)

   def getMediumFormats(self):
       req=ISystemProperties_getMediumFormatsRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISystemProperties_getMediumFormats(req)
       return  IMediumFormat(self.mgr,val._returnval, True)
   def getDefaultHardDiskFormat(self):
       req=ISystemProperties_getDefaultHardDiskFormatRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISystemProperties_getDefaultHardDiskFormat(req)
       return  String(self.mgr,val._returnval)
   def setDefaultHardDiskFormat(self, value):
       req=ISystemProperties_setDefaultHardDiskFormatRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._defaultHardDiskFormat = value
       else:
            req._defaultHardDiskFormat = value.handle
       self.mgr.getPort().ISystemProperties_setDefaultHardDiskFormat(req)

   def getFreeDiskSpaceWarning(self):
       req=ISystemProperties_getFreeDiskSpaceWarningRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISystemProperties_getFreeDiskSpaceWarning(req)
       return  Long(self.mgr,val._returnval)
   def setFreeDiskSpaceWarning(self, value):
       req=ISystemProperties_setFreeDiskSpaceWarningRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._freeDiskSpaceWarning = value
       else:
            req._freeDiskSpaceWarning = value.handle
       self.mgr.getPort().ISystemProperties_setFreeDiskSpaceWarning(req)

   def getFreeDiskSpacePercentWarning(self):
       req=ISystemProperties_getFreeDiskSpacePercentWarningRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISystemProperties_getFreeDiskSpacePercentWarning(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def setFreeDiskSpacePercentWarning(self, value):
       req=ISystemProperties_setFreeDiskSpacePercentWarningRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._freeDiskSpacePercentWarning = value
       else:
            req._freeDiskSpacePercentWarning = value.handle
       self.mgr.getPort().ISystemProperties_setFreeDiskSpacePercentWarning(req)

   def getFreeDiskSpaceError(self):
       req=ISystemProperties_getFreeDiskSpaceErrorRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISystemProperties_getFreeDiskSpaceError(req)
       return  Long(self.mgr,val._returnval)
   def setFreeDiskSpaceError(self, value):
       req=ISystemProperties_setFreeDiskSpaceErrorRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._freeDiskSpaceError = value
       else:
            req._freeDiskSpaceError = value.handle
       self.mgr.getPort().ISystemProperties_setFreeDiskSpaceError(req)

   def getFreeDiskSpacePercentError(self):
       req=ISystemProperties_getFreeDiskSpacePercentErrorRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISystemProperties_getFreeDiskSpacePercentError(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def setFreeDiskSpacePercentError(self, value):
       req=ISystemProperties_setFreeDiskSpacePercentErrorRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._freeDiskSpacePercentError = value
       else:
            req._freeDiskSpacePercentError = value.handle
       self.mgr.getPort().ISystemProperties_setFreeDiskSpacePercentError(req)

   def getVRDEAuthLibrary(self):
       req=ISystemProperties_getVRDEAuthLibraryRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISystemProperties_getVRDEAuthLibrary(req)
       return  String(self.mgr,val._returnval)
   def setVRDEAuthLibrary(self, value):
       req=ISystemProperties_setVRDEAuthLibraryRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._VRDEAuthLibrary = value
       else:
            req._VRDEAuthLibrary = value.handle
       self.mgr.getPort().ISystemProperties_setVRDEAuthLibrary(req)

   def getWebServiceAuthLibrary(self):
       req=ISystemProperties_getWebServiceAuthLibraryRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISystemProperties_getWebServiceAuthLibrary(req)
       return  String(self.mgr,val._returnval)
   def setWebServiceAuthLibrary(self, value):
       req=ISystemProperties_setWebServiceAuthLibraryRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._webServiceAuthLibrary = value
       else:
            req._webServiceAuthLibrary = value.handle
       self.mgr.getPort().ISystemProperties_setWebServiceAuthLibrary(req)

   def getDefaultVRDEExtPack(self):
       req=ISystemProperties_getDefaultVRDEExtPackRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISystemProperties_getDefaultVRDEExtPack(req)
       return  String(self.mgr,val._returnval)
   def setDefaultVRDEExtPack(self, value):
       req=ISystemProperties_setDefaultVRDEExtPackRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._defaultVRDEExtPack = value
       else:
            req._defaultVRDEExtPack = value.handle
       self.mgr.getPort().ISystemProperties_setDefaultVRDEExtPack(req)

   def getLogHistoryCount(self):
       req=ISystemProperties_getLogHistoryCountRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISystemProperties_getLogHistoryCount(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def setLogHistoryCount(self, value):
       req=ISystemProperties_setLogHistoryCountRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._logHistoryCount = value
       else:
            req._logHistoryCount = value.handle
       self.mgr.getPort().ISystemProperties_setLogHistoryCount(req)

   def getDefaultAudioDriver(self):
       req=ISystemProperties_getDefaultAudioDriverRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISystemProperties_getDefaultAudioDriver(req)
       return  AudioDriverType(self.mgr,val._returnval)


   _Attrs_={         'minGuestRAM':[getMinGuestRAM,None],
         'maxGuestRAM':[getMaxGuestRAM,None],
         'minGuestVRAM':[getMinGuestVRAM,None],
         'maxGuestVRAM':[getMaxGuestVRAM,None],
         'minGuestCPUCount':[getMinGuestCPUCount,None],
         'maxGuestCPUCount':[getMaxGuestCPUCount,None],
         'maxGuestMonitors':[getMaxGuestMonitors,None],
         'infoVDSize':[getInfoVDSize,None],
         'serialPortCount':[getSerialPortCount,None],
         'parallelPortCount':[getParallelPortCount,None],
         'maxBootPosition':[getMaxBootPosition,None],
         'defaultMachineFolder':[getDefaultMachineFolder,setDefaultMachineFolder,
        ],
         'mediumFormats':[getMediumFormats,None],
         'defaultHardDiskFormat':[getDefaultHardDiskFormat,setDefaultHardDiskFormat,
        ],
         'freeDiskSpaceWarning':[getFreeDiskSpaceWarning,setFreeDiskSpaceWarning,
        ],
         'freeDiskSpacePercentWarning':[getFreeDiskSpacePercentWarning,setFreeDiskSpacePercentWarning,
        ],
         'freeDiskSpaceError':[getFreeDiskSpaceError,setFreeDiskSpaceError,
        ],
         'freeDiskSpacePercentError':[getFreeDiskSpacePercentError,setFreeDiskSpacePercentError,
        ],
         'VRDEAuthLibrary':[getVRDEAuthLibrary,setVRDEAuthLibrary,
        ],
         'webServiceAuthLibrary':[getWebServiceAuthLibrary,setWebServiceAuthLibrary,
        ],
         'defaultVRDEExtPack':[getDefaultVRDEExtPack,setDefaultVRDEExtPack,
        ],
         'logHistoryCount':[getLogHistoryCount,setLogHistoryCount,
        ],
         'defaultAudioDriver':[getDefaultAudioDriver,None]}

class IGuest(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IGuest(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuest._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuest._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def internalGetStatistics(self):
       req=IGuest_internalGetStatisticsRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IGuest_internalGetStatistics(req)
       
       return UnsignedInt(self.mgr,val._cpuUser), UnsignedInt(self.mgr,val._cpuKernel), UnsignedInt(self.mgr,val._cpuIdle), UnsignedInt(self.mgr,val._memTotal), UnsignedInt(self.mgr,val._memFree), UnsignedInt(self.mgr,val._memBalloon), UnsignedInt(self.mgr,val._memShared), UnsignedInt(self.mgr,val._memCache), UnsignedInt(self.mgr,val._pagedTotal), UnsignedInt(self.mgr,val._memAllocTotal), UnsignedInt(self.mgr,val._memFreeTotal), UnsignedInt(self.mgr,val._memBalloonTotal), UnsignedInt(self.mgr,val._memSharedTotal)


   def getFacilityStatus(self, _arg_facility):
       req=IGuest_getFacilityStatusRequestMsg()
       req._this=self.handle
       
       req._facility=_arg_facility
       val=self.mgr.getPort().IGuest_getFacilityStatus(req)
       
       return AdditionsFacilityStatus(self.mgr,val._returnval), Long(self.mgr,val._timestamp)


   def getAdditionsStatus(self, _arg_level):
       req=IGuest_getAdditionsStatusRequestMsg()
       req._this=self.handle
       
       req._level=_arg_level
       val=self.mgr.getPort().IGuest_getAdditionsStatus(req)
       
       return Boolean(self.mgr,val._returnval)


   def setCredentials(self, _arg_userName, _arg_password, _arg_domain, _arg_allowInteractiveLogon):
       req=IGuest_setCredentialsRequestMsg()
       req._this=self.handle
       
       req._userName=_arg_userName
       req._password=_arg_password
       req._domain=_arg_domain
       req._allowInteractiveLogon=_arg_allowInteractiveLogon
       val=self.mgr.getPort().IGuest_setCredentials(req)
       
       return 


   def executeProcess(self, _arg_execName, _arg_flags, _arg_arguments, _arg_environment, _arg_userName, _arg_password, _arg_timeoutMS):
       req=IGuest_executeProcessRequestMsg()
       req._this=self.handle
       
       req._execName=_arg_execName
       req._flags=_arg_flags
       req._arguments=_arg_arguments
       req._environment=_arg_environment
       req._userName=_arg_userName
       req._password=_arg_password
       req._timeoutMS=_arg_timeoutMS
       val=self.mgr.getPort().IGuest_executeProcess(req)
       
       return IProgress(self.mgr,val._returnval), UnsignedInt(self.mgr,val._pid)


   def getProcessOutput(self, _arg_pid, _arg_flags, _arg_timeoutMS, _arg_size):
       req=IGuest_getProcessOutputRequestMsg()
       req._this=self.handle
       
       req._pid=_arg_pid
       req._flags=_arg_flags
       req._timeoutMS=_arg_timeoutMS
       req._size=_arg_size
       val=self.mgr.getPort().IGuest_getProcessOutput(req)
       
       return self.mgr.decodebase64(val._returnval)


   def getProcessStatus(self, _arg_pid):
       req=IGuest_getProcessStatusRequestMsg()
       req._this=self.handle
       
       req._pid=_arg_pid
       val=self.mgr.getPort().IGuest_getProcessStatus(req)
       
       return ExecuteProcessStatus(self.mgr,val._returnval), UnsignedInt(self.mgr,val._exitcode), UnsignedInt(self.mgr,val._flags)


   def copyFromGuest(self, _arg_source, _arg_dest, _arg_userName, _arg_password, _arg_flags):
       req=IGuest_copyFromGuestRequestMsg()
       req._this=self.handle
       
       req._source=_arg_source
       req._dest=_arg_dest
       req._userName=_arg_userName
       req._password=_arg_password
       req._flags=_arg_flags
       val=self.mgr.getPort().IGuest_copyFromGuest(req)
       
       return IProgress(self.mgr,val._returnval)


   def copyToGuest(self, _arg_source, _arg_dest, _arg_userName, _arg_password, _arg_flags):
       req=IGuest_copyToGuestRequestMsg()
       req._this=self.handle
       
       req._source=_arg_source
       req._dest=_arg_dest
       req._userName=_arg_userName
       req._password=_arg_password
       req._flags=_arg_flags
       val=self.mgr.getPort().IGuest_copyToGuest(req)
       
       return IProgress(self.mgr,val._returnval)


   def directoryClose(self, _arg_handle):
       req=IGuest_directoryCloseRequestMsg()
       req._this=self.handle
       
       req._handle=_arg_handle
       val=self.mgr.getPort().IGuest_directoryClose(req)
       
       return 


   def directoryCreate(self, _arg_directory, _arg_userName, _arg_password, _arg_mode, _arg_flags):
       req=IGuest_directoryCreateRequestMsg()
       req._this=self.handle
       
       req._directory=_arg_directory
       req._userName=_arg_userName
       req._password=_arg_password
       req._mode=_arg_mode
       req._flags=_arg_flags
       val=self.mgr.getPort().IGuest_directoryCreate(req)
       
       return 


   def directoryOpen(self, _arg_directory, _arg_filter, _arg_flags, _arg_userName, _arg_password):
       req=IGuest_directoryOpenRequestMsg()
       req._this=self.handle
       
       req._directory=_arg_directory
       req._filter=_arg_filter
       req._flags=_arg_flags
       req._userName=_arg_userName
       req._password=_arg_password
       val=self.mgr.getPort().IGuest_directoryOpen(req)
       
       return UnsignedInt(self.mgr,val._returnval)


   def directoryRead(self, _arg_handle):
       req=IGuest_directoryReadRequestMsg()
       req._this=self.handle
       
       req._handle=_arg_handle
       val=self.mgr.getPort().IGuest_directoryRead(req)
       
       return IGuestDirEntry(self.mgr,val._returnval)


   def fileExists(self, _arg_file, _arg_userName, _arg_password):
       req=IGuest_fileExistsRequestMsg()
       req._this=self.handle
       
       req._file=_arg_file
       req._userName=_arg_userName
       req._password=_arg_password
       val=self.mgr.getPort().IGuest_fileExists(req)
       
       return Boolean(self.mgr,val._returnval)


   def fileQuerySize(self, _arg_file, _arg_userName, _arg_password):
       req=IGuest_fileQuerySizeRequestMsg()
       req._this=self.handle
       
       req._file=_arg_file
       req._userName=_arg_userName
       req._password=_arg_password
       val=self.mgr.getPort().IGuest_fileQuerySize(req)
       
       return Long(self.mgr,val._returnval)


   def setProcessInput(self, _arg_pid, _arg_flags, _arg_timeoutMS, _arg_data):
       req=IGuest_setProcessInputRequestMsg()
       req._this=self.handle
       
       req._pid=_arg_pid
       req._flags=_arg_flags
       req._timeoutMS=_arg_timeoutMS
       req._data=self.mgr.encodebase64(_arg_data)
       val=self.mgr.getPort().IGuest_setProcessInput(req)
       
       return UnsignedInt(self.mgr,val._returnval)


   def updateGuestAdditions(self, _arg_source, _arg_flags):
       req=IGuest_updateGuestAdditionsRequestMsg()
       req._this=self.handle
       
       req._source=_arg_source
       req._flags=_arg_flags
       val=self.mgr.getPort().IGuest_updateGuestAdditions(req)
       
       return IProgress(self.mgr,val._returnval)


   def getOSTypeId(self):
       req=IGuest_getOSTypeIdRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IGuest_getOSTypeId(req)
       return  String(self.mgr,val._returnval)
   def getAdditionsRunLevel(self):
       req=IGuest_getAdditionsRunLevelRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IGuest_getAdditionsRunLevel(req)
       return  AdditionsRunLevelType(self.mgr,val._returnval)
   def getAdditionsVersion(self):
       req=IGuest_getAdditionsVersionRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IGuest_getAdditionsVersion(req)
       return  String(self.mgr,val._returnval)
   def getFacilities(self):
       req=IGuest_getFacilitiesRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IGuest_getFacilities(req)
       return  IAdditionsFacility(self.mgr,val._returnval, True)
   def getMemoryBalloonSize(self):
       req=IGuest_getMemoryBalloonSizeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IGuest_getMemoryBalloonSize(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def setMemoryBalloonSize(self, value):
       req=IGuest_setMemoryBalloonSizeRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._memoryBalloonSize = value
       else:
            req._memoryBalloonSize = value.handle
       self.mgr.getPort().IGuest_setMemoryBalloonSize(req)

   def getStatisticsUpdateInterval(self):
       req=IGuest_getStatisticsUpdateIntervalRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IGuest_getStatisticsUpdateInterval(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def setStatisticsUpdateInterval(self, value):
       req=IGuest_setStatisticsUpdateIntervalRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._statisticsUpdateInterval = value
       else:
            req._statisticsUpdateInterval = value.handle
       self.mgr.getPort().IGuest_setStatisticsUpdateInterval(req)



   _Attrs_={         'OSTypeId':[getOSTypeId,None],
         'additionsRunLevel':[getAdditionsRunLevel,None],
         'additionsVersion':[getAdditionsVersion,None],
         'facilities':[getFacilities,None],
         'memoryBalloonSize':[getMemoryBalloonSize,setMemoryBalloonSize,
        ],
         'statisticsUpdateInterval':[getStatisticsUpdateInterval,setStatisticsUpdateInterval,
        ]}

class IProgress(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IProgress(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IProgress._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IProgress._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def setCurrentOperationProgress(self, _arg_percent):
       req=IProgress_setCurrentOperationProgressRequestMsg()
       req._this=self.handle
       
       req._percent=_arg_percent
       val=self.mgr.getPort().IProgress_setCurrentOperationProgress(req)
       
       return 


   def setNextOperation(self, _arg_nextOperationDescription, _arg_nextOperationsWeight):
       req=IProgress_setNextOperationRequestMsg()
       req._this=self.handle
       
       req._nextOperationDescription=_arg_nextOperationDescription
       req._nextOperationsWeight=_arg_nextOperationsWeight
       val=self.mgr.getPort().IProgress_setNextOperation(req)
       
       return 


   def waitForCompletion(self, _arg_timeout):
       req=IProgress_waitForCompletionRequestMsg()
       req._this=self.handle
       
       req._timeout=_arg_timeout
       val=self.mgr.getPort().IProgress_waitForCompletion(req)
       
       return 


   def waitForOperationCompletion(self, _arg_operation, _arg_timeout):
       req=IProgress_waitForOperationCompletionRequestMsg()
       req._this=self.handle
       
       req._operation=_arg_operation
       req._timeout=_arg_timeout
       val=self.mgr.getPort().IProgress_waitForOperationCompletion(req)
       
       return 


   def waitForAsyncProgressCompletion(self, _arg_pProgressAsync):
       req=IProgress_waitForAsyncProgressCompletionRequestMsg()
       req._this=self.handle
       
       req._pProgressAsync=_arg_pProgressAsync
       val=self.mgr.getPort().IProgress_waitForAsyncProgressCompletion(req)
       
       return 


   def cancel(self):
       req=IProgress_cancelRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IProgress_cancel(req)
       
       return 


   def getId(self):
       req=IProgress_getIdRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IProgress_getId(req)
       return  String(self.mgr,val._returnval)
   def getDescription(self):
       req=IProgress_getDescriptionRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IProgress_getDescription(req)
       return  String(self.mgr,val._returnval)
   def getInitiator(self):
       req=IProgress_getInitiatorRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IProgress_getInitiator(req)
       return  IUnknown(self.mgr,val._returnval)
   def getCancelable(self):
       req=IProgress_getCancelableRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IProgress_getCancelable(req)
       return  Boolean(self.mgr,val._returnval)
   def getPercent(self):
       req=IProgress_getPercentRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IProgress_getPercent(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getTimeRemaining(self):
       req=IProgress_getTimeRemainingRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IProgress_getTimeRemaining(req)
       return  Int(self.mgr,val._returnval)
   def getCompleted(self):
       req=IProgress_getCompletedRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IProgress_getCompleted(req)
       return  Boolean(self.mgr,val._returnval)
   def getCanceled(self):
       req=IProgress_getCanceledRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IProgress_getCanceled(req)
       return  Boolean(self.mgr,val._returnval)
   def getResultCode(self):
       req=IProgress_getResultCodeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IProgress_getResultCode(req)
       return  Int(self.mgr,val._returnval)
   def getErrorInfo(self):
       req=IProgress_getErrorInfoRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IProgress_getErrorInfo(req)
       return  IVirtualBoxErrorInfo(self.mgr,val._returnval)
   def getOperationCount(self):
       req=IProgress_getOperationCountRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IProgress_getOperationCount(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getOperation(self):
       req=IProgress_getOperationRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IProgress_getOperation(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getOperationDescription(self):
       req=IProgress_getOperationDescriptionRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IProgress_getOperationDescription(req)
       return  String(self.mgr,val._returnval)
   def getOperationPercent(self):
       req=IProgress_getOperationPercentRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IProgress_getOperationPercent(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getOperationWeight(self):
       req=IProgress_getOperationWeightRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IProgress_getOperationWeight(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getTimeout(self):
       req=IProgress_getTimeoutRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IProgress_getTimeout(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def setTimeout(self, value):
       req=IProgress_setTimeoutRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._timeout = value
       else:
            req._timeout = value.handle
       self.mgr.getPort().IProgress_setTimeout(req)



   _Attrs_={         'id':[getId,None],
         'description':[getDescription,None],
         'initiator':[getInitiator,None],
         'cancelable':[getCancelable,None],
         'percent':[getPercent,None],
         'timeRemaining':[getTimeRemaining,None],
         'completed':[getCompleted,None],
         'canceled':[getCanceled,None],
         'resultCode':[getResultCode,None],
         'errorInfo':[getErrorInfo,None],
         'operationCount':[getOperationCount,None],
         'operation':[getOperation,None],
         'operationDescription':[getOperationDescription,None],
         'operationPercent':[getOperationPercent,None],
         'operationWeight':[getOperationWeight,None],
         'timeout':[getTimeout,setTimeout,
        ]}

class ISnapshot(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return ISnapshot(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ISnapshot._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ISnapshot._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getChildrenCount(self):
       req=ISnapshot_getChildrenCountRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().ISnapshot_getChildrenCount(req)
       
       return UnsignedInt(self.mgr,val._returnval)


   def getId(self):
       req=ISnapshot_getIdRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISnapshot_getId(req)
       return  String(self.mgr,val._returnval)
   def getName(self):
       req=ISnapshot_getNameRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISnapshot_getName(req)
       return  String(self.mgr,val._returnval)
   def setName(self, value):
       req=ISnapshot_setNameRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._name = value
       else:
            req._name = value.handle
       self.mgr.getPort().ISnapshot_setName(req)

   def getDescription(self):
       req=ISnapshot_getDescriptionRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISnapshot_getDescription(req)
       return  String(self.mgr,val._returnval)
   def setDescription(self, value):
       req=ISnapshot_setDescriptionRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._description = value
       else:
            req._description = value.handle
       self.mgr.getPort().ISnapshot_setDescription(req)

   def getTimeStamp(self):
       req=ISnapshot_getTimeStampRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISnapshot_getTimeStamp(req)
       return  Long(self.mgr,val._returnval)
   def getOnline(self):
       req=ISnapshot_getOnlineRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISnapshot_getOnline(req)
       return  Boolean(self.mgr,val._returnval)
   def getMachine(self):
       req=ISnapshot_getMachineRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISnapshot_getMachine(req)
       return  IMachine(self.mgr,val._returnval)
   def getParent(self):
       req=ISnapshot_getParentRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISnapshot_getParent(req)
       return  ISnapshot(self.mgr,val._returnval)
   def getChildren(self):
       req=ISnapshot_getChildrenRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISnapshot_getChildren(req)
       return  ISnapshot(self.mgr,val._returnval, True)


   _Attrs_={         'id':[getId,None],
         'name':[getName,setName,
        ],
         'description':[getDescription,setDescription,
        ],
         'timeStamp':[getTimeStamp,None],
         'online':[getOnline,None],
         'machine':[getMachine,None],
         'parent':[getParent,None],
         'children':[getChildren,None]}

class IMedium(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IMedium(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IMedium._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IMedium._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def setIDs(self, _arg_setImageId, _arg_imageId, _arg_setParentId, _arg_parentId):
       req=IMedium_setIDsRequestMsg()
       req._this=self.handle
       
       req._setImageId=_arg_setImageId
       req._imageId=_arg_imageId
       req._setParentId=_arg_setParentId
       req._parentId=_arg_parentId
       val=self.mgr.getPort().IMedium_setIDs(req)
       
       return 


   def refreshState(self):
       req=IMedium_refreshStateRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IMedium_refreshState(req)
       
       return MediumState(self.mgr,val._returnval)


   def getSnapshotIds(self, _arg_machineId):
       req=IMedium_getSnapshotIdsRequestMsg()
       req._this=self.handle
       
       req._machineId=_arg_machineId
       val=self.mgr.getPort().IMedium_getSnapshotIds(req)
       
       return String(self.mgr,val._returnval, True)


   def lockRead(self):
       req=IMedium_lockReadRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IMedium_lockRead(req)
       
       return MediumState(self.mgr,val._returnval)


   def unlockRead(self):
       req=IMedium_unlockReadRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IMedium_unlockRead(req)
       
       return MediumState(self.mgr,val._returnval)


   def lockWrite(self):
       req=IMedium_lockWriteRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IMedium_lockWrite(req)
       
       return MediumState(self.mgr,val._returnval)


   def unlockWrite(self):
       req=IMedium_unlockWriteRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IMedium_unlockWrite(req)
       
       return MediumState(self.mgr,val._returnval)


   def close(self):
       req=IMedium_closeRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IMedium_close(req)
       
       return 


   def getProperty(self, _arg_name):
       req=IMedium_getPropertyRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       val=self.mgr.getPort().IMedium_getProperty(req)
       
       return String(self.mgr,val._returnval)


   def setProperty(self, _arg_name, _arg_value):
       req=IMedium_setPropertyRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       req._value=_arg_value
       val=self.mgr.getPort().IMedium_setProperty(req)
       
       return 


   def getProperties(self, _arg_names):
       req=IMedium_getPropertiesRequestMsg()
       req._this=self.handle
       
       req._names=_arg_names
       val=self.mgr.getPort().IMedium_getProperties(req)
       
       return String(self.mgr,val._returnval, True), String(self.mgr,val._returnNames, True)


   def setProperties(self, _arg_names, _arg_values):
       req=IMedium_setPropertiesRequestMsg()
       req._this=self.handle
       
       req._names=_arg_names
       req._values=_arg_values
       val=self.mgr.getPort().IMedium_setProperties(req)
       
       return 


   def createBaseStorage(self, _arg_logicalSize, _arg_variant):
       req=IMedium_createBaseStorageRequestMsg()
       req._this=self.handle
       
       req._logicalSize=_arg_logicalSize
       req._variant=_arg_variant
       val=self.mgr.getPort().IMedium_createBaseStorage(req)
       
       return IProgress(self.mgr,val._returnval)


   def deleteStorage(self):
       req=IMedium_deleteStorageRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IMedium_deleteStorage(req)
       
       return IProgress(self.mgr,val._returnval)


   def createDiffStorage(self, _arg_target, _arg_variant):
       req=IMedium_createDiffStorageRequestMsg()
       req._this=self.handle
       
       req._target=_arg_target
       req._variant=_arg_variant
       val=self.mgr.getPort().IMedium_createDiffStorage(req)
       
       return IProgress(self.mgr,val._returnval)


   def mergeTo(self, _arg_target):
       req=IMedium_mergeToRequestMsg()
       req._this=self.handle
       
       req._target=_arg_target
       val=self.mgr.getPort().IMedium_mergeTo(req)
       
       return IProgress(self.mgr,val._returnval)


   def cloneTo(self, _arg_target, _arg_variant, _arg_parent):
       req=IMedium_cloneToRequestMsg()
       req._this=self.handle
       
       req._target=_arg_target
       req._variant=_arg_variant
       req._parent=_arg_parent
       val=self.mgr.getPort().IMedium_cloneTo(req)
       
       return IProgress(self.mgr,val._returnval)


   def compact(self):
       req=IMedium_compactRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IMedium_compact(req)
       
       return IProgress(self.mgr,val._returnval)


   def resize(self, _arg_logicalSize):
       req=IMedium_resizeRequestMsg()
       req._this=self.handle
       
       req._logicalSize=_arg_logicalSize
       val=self.mgr.getPort().IMedium_resize(req)
       
       return IProgress(self.mgr,val._returnval)


   def reset(self):
       req=IMedium_resetRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IMedium_reset(req)
       
       return IProgress(self.mgr,val._returnval)


   def getId(self):
       req=IMedium_getIdRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMedium_getId(req)
       return  String(self.mgr,val._returnval)
   def getDescription(self):
       req=IMedium_getDescriptionRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMedium_getDescription(req)
       return  String(self.mgr,val._returnval)
   def setDescription(self, value):
       req=IMedium_setDescriptionRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._description = value
       else:
            req._description = value.handle
       self.mgr.getPort().IMedium_setDescription(req)

   def getState(self):
       req=IMedium_getStateRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMedium_getState(req)
       return  MediumState(self.mgr,val._returnval)
   def getVariant(self):
       req=IMedium_getVariantRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMedium_getVariant(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getLocation(self):
       req=IMedium_getLocationRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMedium_getLocation(req)
       return  String(self.mgr,val._returnval)
   def setLocation(self, value):
       req=IMedium_setLocationRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._location = value
       else:
            req._location = value.handle
       self.mgr.getPort().IMedium_setLocation(req)

   def getName(self):
       req=IMedium_getNameRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMedium_getName(req)
       return  String(self.mgr,val._returnval)
   def getDeviceType(self):
       req=IMedium_getDeviceTypeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMedium_getDeviceType(req)
       return  DeviceType(self.mgr,val._returnval)
   def getHostDrive(self):
       req=IMedium_getHostDriveRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMedium_getHostDrive(req)
       return  Boolean(self.mgr,val._returnval)
   def getSize(self):
       req=IMedium_getSizeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMedium_getSize(req)
       return  Long(self.mgr,val._returnval)
   def getFormat(self):
       req=IMedium_getFormatRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMedium_getFormat(req)
       return  String(self.mgr,val._returnval)
   def getMediumFormat(self):
       req=IMedium_getMediumFormatRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMedium_getMediumFormat(req)
       return  IMediumFormat(self.mgr,val._returnval)
   def getType(self):
       req=IMedium_getTypeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMedium_getType(req)
       return  MediumType(self.mgr,val._returnval)
   def setType(self, value):
       req=IMedium_setTypeRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._type = value
       else:
            req._type = value.handle
       self.mgr.getPort().IMedium_setType(req)

   def getAllowedTypes(self):
       req=IMedium_getAllowedTypesRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMedium_getAllowedTypes(req)
       return  MediumType(self.mgr,val._returnval, True)
   def getParent(self):
       req=IMedium_getParentRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMedium_getParent(req)
       return  IMedium(self.mgr,val._returnval)
   def getChildren(self):
       req=IMedium_getChildrenRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMedium_getChildren(req)
       return  IMedium(self.mgr,val._returnval, True)
   def getBase(self):
       req=IMedium_getBaseRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMedium_getBase(req)
       return  IMedium(self.mgr,val._returnval)
   def getReadOnly(self):
       req=IMedium_getReadOnlyRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMedium_getReadOnly(req)
       return  Boolean(self.mgr,val._returnval)
   def getLogicalSize(self):
       req=IMedium_getLogicalSizeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMedium_getLogicalSize(req)
       return  Long(self.mgr,val._returnval)
   def getAutoReset(self):
       req=IMedium_getAutoResetRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMedium_getAutoReset(req)
       return  Boolean(self.mgr,val._returnval)
   def setAutoReset(self, value):
       req=IMedium_setAutoResetRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._autoReset = value
       else:
            req._autoReset = value.handle
       self.mgr.getPort().IMedium_setAutoReset(req)

   def getLastAccessError(self):
       req=IMedium_getLastAccessErrorRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMedium_getLastAccessError(req)
       return  String(self.mgr,val._returnval)
   def getMachineIds(self):
       req=IMedium_getMachineIdsRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMedium_getMachineIds(req)
       return  String(self.mgr,val._returnval, True)


   _Attrs_={         'id':[getId,None],
         'description':[getDescription,setDescription,
        ],
         'state':[getState,None],
         'variant':[getVariant,None],
         'location':[getLocation,setLocation,
        ],
         'name':[getName,None],
         'deviceType':[getDeviceType,None],
         'hostDrive':[getHostDrive,None],
         'size':[getSize,None],
         'format':[getFormat,None],
         'mediumFormat':[getMediumFormat,None],
         'type':[getType,setType,
        ],
         'allowedTypes':[getAllowedTypes,None],
         'parent':[getParent,None],
         'children':[getChildren,None],
         'base':[getBase,None],
         'readOnly':[getReadOnly,None],
         'logicalSize':[getLogicalSize,None],
         'autoReset':[getAutoReset,setAutoReset,
        ],
         'lastAccessError':[getLastAccessError,None],
         'machineIds':[getMachineIds,None]}

class IMediumFormat(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IMediumFormat(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IMediumFormat._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IMediumFormat._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def describeFileExtensions(self):
       req=IMediumFormat_describeFileExtensionsRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IMediumFormat_describeFileExtensions(req)
       
       return String(self.mgr,val._extensions, True), DeviceType(self.mgr,val._type, True)


   def describeProperties(self):
       req=IMediumFormat_describePropertiesRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IMediumFormat_describeProperties(req)
       
       return String(self.mgr,val._names, True), String(self.mgr,val._description, True), DataType(self.mgr,val._types, True), UnsignedInt(self.mgr,val._flags, True), String(self.mgr,val._defaults, True)


   def getId(self):
       req=IMediumFormat_getIdRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMediumFormat_getId(req)
       return  String(self.mgr,val._returnval)
   def getName(self):
       req=IMediumFormat_getNameRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMediumFormat_getName(req)
       return  String(self.mgr,val._returnval)
   def getCapabilities(self):
       req=IMediumFormat_getCapabilitiesRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMediumFormat_getCapabilities(req)
       return  UnsignedInt(self.mgr,val._returnval)


   _Attrs_={         'id':[getId,None],
         'name':[getName,None],
         'capabilities':[getCapabilities,None]}

class IKeyboard(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IKeyboard(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IKeyboard._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IKeyboard._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def putScancode(self, _arg_scancode):
       req=IKeyboard_putScancodeRequestMsg()
       req._this=self.handle
       
       req._scancode=_arg_scancode
       val=self.mgr.getPort().IKeyboard_putScancode(req)
       
       return 


   def putScancodes(self, _arg_scancodes):
       req=IKeyboard_putScancodesRequestMsg()
       req._this=self.handle
       
       req._scancodes=_arg_scancodes
       val=self.mgr.getPort().IKeyboard_putScancodes(req)
       
       return UnsignedInt(self.mgr,val._returnval)


   def putCAD(self):
       req=IKeyboard_putCADRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IKeyboard_putCAD(req)
       
       return 


   def getEventSource(self):
       req=IKeyboard_getEventSourceRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IKeyboard_getEventSource(req)
       return  IEventSource(self.mgr,val._returnval)


   _Attrs_={         'eventSource':[getEventSource,None]}

class IMouse(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IMouse(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IMouse._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IMouse._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def putMouseEvent(self, _arg_dx, _arg_dy, _arg_dz, _arg_dw, _arg_buttonState):
       req=IMouse_putMouseEventRequestMsg()
       req._this=self.handle
       
       req._dx=_arg_dx
       req._dy=_arg_dy
       req._dz=_arg_dz
       req._dw=_arg_dw
       req._buttonState=_arg_buttonState
       val=self.mgr.getPort().IMouse_putMouseEvent(req)
       
       return 


   def putMouseEventAbsolute(self, _arg_x, _arg_y, _arg_dz, _arg_dw, _arg_buttonState):
       req=IMouse_putMouseEventAbsoluteRequestMsg()
       req._this=self.handle
       
       req._x=_arg_x
       req._y=_arg_y
       req._dz=_arg_dz
       req._dw=_arg_dw
       req._buttonState=_arg_buttonState
       val=self.mgr.getPort().IMouse_putMouseEventAbsolute(req)
       
       return 


   def getAbsoluteSupported(self):
       req=IMouse_getAbsoluteSupportedRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMouse_getAbsoluteSupported(req)
       return  Boolean(self.mgr,val._returnval)
   def getRelativeSupported(self):
       req=IMouse_getRelativeSupportedRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMouse_getRelativeSupported(req)
       return  Boolean(self.mgr,val._returnval)
   def getNeedsHostCursor(self):
       req=IMouse_getNeedsHostCursorRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMouse_getNeedsHostCursor(req)
       return  Boolean(self.mgr,val._returnval)
   def getEventSource(self):
       req=IMouse_getEventSourceRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMouse_getEventSource(req)
       return  IEventSource(self.mgr,val._returnval)


   _Attrs_={         'absoluteSupported':[getAbsoluteSupported,None],
         'relativeSupported':[getRelativeSupported,None],
         'needsHostCursor':[getNeedsHostCursor,None],
         'eventSource':[getEventSource,None]}

class IDisplay(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IDisplay(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IDisplay._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IDisplay._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getScreenResolution(self, _arg_screenId):
       req=IDisplay_getScreenResolutionRequestMsg()
       req._this=self.handle
       
       req._screenId=_arg_screenId
       val=self.mgr.getPort().IDisplay_getScreenResolution(req)
       
       return UnsignedInt(self.mgr,val._width), UnsignedInt(self.mgr,val._height), UnsignedInt(self.mgr,val._bitsPerPixel)


   def setFramebuffer(self, _arg_screenId, _arg_framebuffer):
       req=IDisplay_setFramebufferRequestMsg()
       req._this=self.handle
       
       req._screenId=_arg_screenId
       req._framebuffer=_arg_framebuffer
       val=self.mgr.getPort().IDisplay_setFramebuffer(req)
       
       return 


   def getFramebuffer(self, _arg_screenId):
       req=IDisplay_getFramebufferRequestMsg()
       req._this=self.handle
       
       req._screenId=_arg_screenId
       val=self.mgr.getPort().IDisplay_getFramebuffer(req)
       
       return IFramebuffer(self.mgr,val._framebuffer), Int(self.mgr,val._xOrigin), Int(self.mgr,val._yOrigin)


   def setVideoModeHint(self, _arg_width, _arg_height, _arg_bitsPerPixel, _arg_display):
       req=IDisplay_setVideoModeHintRequestMsg()
       req._this=self.handle
       
       req._width=_arg_width
       req._height=_arg_height
       req._bitsPerPixel=_arg_bitsPerPixel
       req._display=_arg_display
       val=self.mgr.getPort().IDisplay_setVideoModeHint(req)
       
       return 


   def setSeamlessMode(self, _arg_enabled):
       req=IDisplay_setSeamlessModeRequestMsg()
       req._this=self.handle
       
       req._enabled=_arg_enabled
       val=self.mgr.getPort().IDisplay_setSeamlessMode(req)
       
       return 


   def takeScreenShot(self, _arg_screenId, _arg_address, _arg_width, _arg_height):
       req=IDisplay_takeScreenShotRequestMsg()
       req._this=self.handle
       
       req._screenId=_arg_screenId
       req._address=_arg_address
       req._width=_arg_width
       req._height=_arg_height
       val=self.mgr.getPort().IDisplay_takeScreenShot(req)
       
       return 


   def takeScreenShotToArray(self, _arg_screenId, _arg_width, _arg_height):
       req=IDisplay_takeScreenShotToArrayRequestMsg()
       req._this=self.handle
       
       req._screenId=_arg_screenId
       req._width=_arg_width
       req._height=_arg_height
       val=self.mgr.getPort().IDisplay_takeScreenShotToArray(req)
       
       return self.mgr.decodebase64(val._returnval)


   def takeScreenShotPNGToArray(self, _arg_screenId, _arg_width, _arg_height):
       req=IDisplay_takeScreenShotPNGToArrayRequestMsg()
       req._this=self.handle
       
       req._screenId=_arg_screenId
       req._width=_arg_width
       req._height=_arg_height
       val=self.mgr.getPort().IDisplay_takeScreenShotPNGToArray(req)
       
       return self.mgr.decodebase64(val._returnval)


   def drawToScreen(self, _arg_screenId, _arg_address, _arg_x, _arg_y, _arg_width, _arg_height):
       req=IDisplay_drawToScreenRequestMsg()
       req._this=self.handle
       
       req._screenId=_arg_screenId
       req._address=_arg_address
       req._x=_arg_x
       req._y=_arg_y
       req._width=_arg_width
       req._height=_arg_height
       val=self.mgr.getPort().IDisplay_drawToScreen(req)
       
       return 


   def invalidateAndUpdate(self):
       req=IDisplay_invalidateAndUpdateRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IDisplay_invalidateAndUpdate(req)
       
       return 


   def resizeCompleted(self, _arg_screenId):
       req=IDisplay_resizeCompletedRequestMsg()
       req._this=self.handle
       
       req._screenId=_arg_screenId
       val=self.mgr.getPort().IDisplay_resizeCompleted(req)
       
       return 


   def completeVHWACommand(self, _arg_command):
       req=IDisplay_completeVHWACommandRequestMsg()
       req._this=self.handle
       
       req._command=_arg_command
       val=self.mgr.getPort().IDisplay_completeVHWACommand(req)
       
       return 




   _Attrs_={}

class INetworkAdapter(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return INetworkAdapter(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = INetworkAdapter._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = INetworkAdapter._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getProperty(self, _arg_key):
       req=INetworkAdapter_getPropertyRequestMsg()
       req._this=self.handle
       
       req._key=_arg_key
       val=self.mgr.getPort().INetworkAdapter_getProperty(req)
       
       return String(self.mgr,val._returnval)


   def setProperty(self, _arg_key, _arg_value):
       req=INetworkAdapter_setPropertyRequestMsg()
       req._this=self.handle
       
       req._key=_arg_key
       req._value=_arg_value
       val=self.mgr.getPort().INetworkAdapter_setProperty(req)
       
       return 


   def getProperties(self, _arg_names):
       req=INetworkAdapter_getPropertiesRequestMsg()
       req._this=self.handle
       
       req._names=_arg_names
       val=self.mgr.getPort().INetworkAdapter_getProperties(req)
       
       return String(self.mgr,val._returnval, True), String(self.mgr,val._returnNames, True)


   def getAdapterType(self):
       req=INetworkAdapter_getAdapterTypeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INetworkAdapter_getAdapterType(req)
       return  NetworkAdapterType(self.mgr,val._returnval)
   def setAdapterType(self, value):
       req=INetworkAdapter_setAdapterTypeRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._adapterType = value
       else:
            req._adapterType = value.handle
       self.mgr.getPort().INetworkAdapter_setAdapterType(req)

   def getSlot(self):
       req=INetworkAdapter_getSlotRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INetworkAdapter_getSlot(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getEnabled(self):
       req=INetworkAdapter_getEnabledRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INetworkAdapter_getEnabled(req)
       return  Boolean(self.mgr,val._returnval)
   def setEnabled(self, value):
       req=INetworkAdapter_setEnabledRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._enabled = value
       else:
            req._enabled = value.handle
       self.mgr.getPort().INetworkAdapter_setEnabled(req)

   def getMACAddress(self):
       req=INetworkAdapter_getMACAddressRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INetworkAdapter_getMACAddress(req)
       return  String(self.mgr,val._returnval)
   def setMACAddress(self, value):
       req=INetworkAdapter_setMACAddressRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._MACAddress = value
       else:
            req._MACAddress = value.handle
       self.mgr.getPort().INetworkAdapter_setMACAddress(req)

   def getAttachmentType(self):
       req=INetworkAdapter_getAttachmentTypeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INetworkAdapter_getAttachmentType(req)
       return  NetworkAttachmentType(self.mgr,val._returnval)
   def setAttachmentType(self, value):
       req=INetworkAdapter_setAttachmentTypeRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._attachmentType = value
       else:
            req._attachmentType = value.handle
       self.mgr.getPort().INetworkAdapter_setAttachmentType(req)

   def getBridgedInterface(self):
       req=INetworkAdapter_getBridgedInterfaceRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INetworkAdapter_getBridgedInterface(req)
       return  String(self.mgr,val._returnval)
   def setBridgedInterface(self, value):
       req=INetworkAdapter_setBridgedInterfaceRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._bridgedInterface = value
       else:
            req._bridgedInterface = value.handle
       self.mgr.getPort().INetworkAdapter_setBridgedInterface(req)

   def getHostOnlyInterface(self):
       req=INetworkAdapter_getHostOnlyInterfaceRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INetworkAdapter_getHostOnlyInterface(req)
       return  String(self.mgr,val._returnval)
   def setHostOnlyInterface(self, value):
       req=INetworkAdapter_setHostOnlyInterfaceRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._hostOnlyInterface = value
       else:
            req._hostOnlyInterface = value.handle
       self.mgr.getPort().INetworkAdapter_setHostOnlyInterface(req)

   def getInternalNetwork(self):
       req=INetworkAdapter_getInternalNetworkRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INetworkAdapter_getInternalNetwork(req)
       return  String(self.mgr,val._returnval)
   def setInternalNetwork(self, value):
       req=INetworkAdapter_setInternalNetworkRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._internalNetwork = value
       else:
            req._internalNetwork = value.handle
       self.mgr.getPort().INetworkAdapter_setInternalNetwork(req)

   def getNATNetwork(self):
       req=INetworkAdapter_getNATNetworkRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INetworkAdapter_getNATNetwork(req)
       return  String(self.mgr,val._returnval)
   def setNATNetwork(self, value):
       req=INetworkAdapter_setNATNetworkRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._NATNetwork = value
       else:
            req._NATNetwork = value.handle
       self.mgr.getPort().INetworkAdapter_setNATNetwork(req)

   def getGenericDriver(self):
       req=INetworkAdapter_getGenericDriverRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INetworkAdapter_getGenericDriver(req)
       return  String(self.mgr,val._returnval)
   def setGenericDriver(self, value):
       req=INetworkAdapter_setGenericDriverRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._genericDriver = value
       else:
            req._genericDriver = value.handle
       self.mgr.getPort().INetworkAdapter_setGenericDriver(req)

   def getCableConnected(self):
       req=INetworkAdapter_getCableConnectedRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INetworkAdapter_getCableConnected(req)
       return  Boolean(self.mgr,val._returnval)
   def setCableConnected(self, value):
       req=INetworkAdapter_setCableConnectedRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._cableConnected = value
       else:
            req._cableConnected = value.handle
       self.mgr.getPort().INetworkAdapter_setCableConnected(req)

   def getLineSpeed(self):
       req=INetworkAdapter_getLineSpeedRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INetworkAdapter_getLineSpeed(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def setLineSpeed(self, value):
       req=INetworkAdapter_setLineSpeedRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._lineSpeed = value
       else:
            req._lineSpeed = value.handle
       self.mgr.getPort().INetworkAdapter_setLineSpeed(req)

   def getPromiscModePolicy(self):
       req=INetworkAdapter_getPromiscModePolicyRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INetworkAdapter_getPromiscModePolicy(req)
       return  NetworkAdapterPromiscModePolicy(self.mgr,val._returnval)
   def setPromiscModePolicy(self, value):
       req=INetworkAdapter_setPromiscModePolicyRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._promiscModePolicy = value
       else:
            req._promiscModePolicy = value.handle
       self.mgr.getPort().INetworkAdapter_setPromiscModePolicy(req)

   def getTraceEnabled(self):
       req=INetworkAdapter_getTraceEnabledRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INetworkAdapter_getTraceEnabled(req)
       return  Boolean(self.mgr,val._returnval)
   def setTraceEnabled(self, value):
       req=INetworkAdapter_setTraceEnabledRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._traceEnabled = value
       else:
            req._traceEnabled = value.handle
       self.mgr.getPort().INetworkAdapter_setTraceEnabled(req)

   def getTraceFile(self):
       req=INetworkAdapter_getTraceFileRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INetworkAdapter_getTraceFile(req)
       return  String(self.mgr,val._returnval)
   def setTraceFile(self, value):
       req=INetworkAdapter_setTraceFileRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._traceFile = value
       else:
            req._traceFile = value.handle
       self.mgr.getPort().INetworkAdapter_setTraceFile(req)

   def getNatDriver(self):
       req=INetworkAdapter_getNatDriverRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INetworkAdapter_getNatDriver(req)
       return  INATEngine(self.mgr,val._returnval)
   def getBootPriority(self):
       req=INetworkAdapter_getBootPriorityRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INetworkAdapter_getBootPriority(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def setBootPriority(self, value):
       req=INetworkAdapter_setBootPriorityRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._bootPriority = value
       else:
            req._bootPriority = value.handle
       self.mgr.getPort().INetworkAdapter_setBootPriority(req)

   def getBandwidthGroup(self):
       req=INetworkAdapter_getBandwidthGroupRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INetworkAdapter_getBandwidthGroup(req)
       return  IBandwidthGroup(self.mgr,val._returnval)
   def setBandwidthGroup(self, value):
       req=INetworkAdapter_setBandwidthGroupRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._bandwidthGroup = value
       else:
            req._bandwidthGroup = value.handle
       self.mgr.getPort().INetworkAdapter_setBandwidthGroup(req)



   _Attrs_={         'adapterType':[getAdapterType,setAdapterType,
        ],
         'slot':[getSlot,None],
         'enabled':[getEnabled,setEnabled,
        ],
         'MACAddress':[getMACAddress,setMACAddress,
        ],
         'attachmentType':[getAttachmentType,setAttachmentType,
        ],
         'bridgedInterface':[getBridgedInterface,setBridgedInterface,
        ],
         'hostOnlyInterface':[getHostOnlyInterface,setHostOnlyInterface,
        ],
         'internalNetwork':[getInternalNetwork,setInternalNetwork,
        ],
         'NATNetwork':[getNATNetwork,setNATNetwork,
        ],
         'genericDriver':[getGenericDriver,setGenericDriver,
        ],
         'cableConnected':[getCableConnected,setCableConnected,
        ],
         'lineSpeed':[getLineSpeed,setLineSpeed,
        ],
         'promiscModePolicy':[getPromiscModePolicy,setPromiscModePolicy,
        ],
         'traceEnabled':[getTraceEnabled,setTraceEnabled,
        ],
         'traceFile':[getTraceFile,setTraceFile,
        ],
         'natDriver':[getNatDriver,None],
         'bootPriority':[getBootPriority,setBootPriority,
        ],
         'bandwidthGroup':[getBandwidthGroup,setBandwidthGroup,
        ]}

class ISerialPort(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return ISerialPort(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ISerialPort._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ISerialPort._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getSlot(self):
       req=ISerialPort_getSlotRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISerialPort_getSlot(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getEnabled(self):
       req=ISerialPort_getEnabledRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISerialPort_getEnabled(req)
       return  Boolean(self.mgr,val._returnval)
   def setEnabled(self, value):
       req=ISerialPort_setEnabledRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._enabled = value
       else:
            req._enabled = value.handle
       self.mgr.getPort().ISerialPort_setEnabled(req)

   def getIOBase(self):
       req=ISerialPort_getIOBaseRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISerialPort_getIOBase(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def setIOBase(self, value):
       req=ISerialPort_setIOBaseRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._IOBase = value
       else:
            req._IOBase = value.handle
       self.mgr.getPort().ISerialPort_setIOBase(req)

   def getIRQ(self):
       req=ISerialPort_getIRQRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISerialPort_getIRQ(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def setIRQ(self, value):
       req=ISerialPort_setIRQRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._IRQ = value
       else:
            req._IRQ = value.handle
       self.mgr.getPort().ISerialPort_setIRQ(req)

   def getHostMode(self):
       req=ISerialPort_getHostModeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISerialPort_getHostMode(req)
       return  PortMode(self.mgr,val._returnval)
   def setHostMode(self, value):
       req=ISerialPort_setHostModeRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._hostMode = value
       else:
            req._hostMode = value.handle
       self.mgr.getPort().ISerialPort_setHostMode(req)

   def getServer(self):
       req=ISerialPort_getServerRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISerialPort_getServer(req)
       return  Boolean(self.mgr,val._returnval)
   def setServer(self, value):
       req=ISerialPort_setServerRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._server = value
       else:
            req._server = value.handle
       self.mgr.getPort().ISerialPort_setServer(req)

   def getPath(self):
       req=ISerialPort_getPathRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISerialPort_getPath(req)
       return  String(self.mgr,val._returnval)
   def setPath(self, value):
       req=ISerialPort_setPathRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._path = value
       else:
            req._path = value.handle
       self.mgr.getPort().ISerialPort_setPath(req)



   _Attrs_={         'slot':[getSlot,None],
         'enabled':[getEnabled,setEnabled,
        ],
         'IOBase':[getIOBase,setIOBase,
        ],
         'IRQ':[getIRQ,setIRQ,
        ],
         'hostMode':[getHostMode,setHostMode,
        ],
         'server':[getServer,setServer,
        ],
         'path':[getPath,setPath,
        ]}

class IParallelPort(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IParallelPort(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IParallelPort._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IParallelPort._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getSlot(self):
       req=IParallelPort_getSlotRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IParallelPort_getSlot(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getEnabled(self):
       req=IParallelPort_getEnabledRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IParallelPort_getEnabled(req)
       return  Boolean(self.mgr,val._returnval)
   def setEnabled(self, value):
       req=IParallelPort_setEnabledRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._enabled = value
       else:
            req._enabled = value.handle
       self.mgr.getPort().IParallelPort_setEnabled(req)

   def getIOBase(self):
       req=IParallelPort_getIOBaseRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IParallelPort_getIOBase(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def setIOBase(self, value):
       req=IParallelPort_setIOBaseRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._IOBase = value
       else:
            req._IOBase = value.handle
       self.mgr.getPort().IParallelPort_setIOBase(req)

   def getIRQ(self):
       req=IParallelPort_getIRQRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IParallelPort_getIRQ(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def setIRQ(self, value):
       req=IParallelPort_setIRQRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._IRQ = value
       else:
            req._IRQ = value.handle
       self.mgr.getPort().IParallelPort_setIRQ(req)

   def getPath(self):
       req=IParallelPort_getPathRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IParallelPort_getPath(req)
       return  String(self.mgr,val._returnval)
   def setPath(self, value):
       req=IParallelPort_setPathRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._path = value
       else:
            req._path = value.handle
       self.mgr.getPort().IParallelPort_setPath(req)



   _Attrs_={         'slot':[getSlot,None],
         'enabled':[getEnabled,setEnabled,
        ],
         'IOBase':[getIOBase,setIOBase,
        ],
         'IRQ':[getIRQ,setIRQ,
        ],
         'path':[getPath,setPath,
        ]}

class IUSBController(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IUSBController(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IUSBController._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IUSBController._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def createDeviceFilter(self, _arg_name):
       req=IUSBController_createDeviceFilterRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       val=self.mgr.getPort().IUSBController_createDeviceFilter(req)
       
       return IUSBDeviceFilter(self.mgr,val._returnval)


   def insertDeviceFilter(self, _arg_position, _arg_filter):
       req=IUSBController_insertDeviceFilterRequestMsg()
       req._this=self.handle
       
       req._position=_arg_position
       req._filter=_arg_filter
       val=self.mgr.getPort().IUSBController_insertDeviceFilter(req)
       
       return 


   def removeDeviceFilter(self, _arg_position):
       req=IUSBController_removeDeviceFilterRequestMsg()
       req._this=self.handle
       
       req._position=_arg_position
       val=self.mgr.getPort().IUSBController_removeDeviceFilter(req)
       
       return IUSBDeviceFilter(self.mgr,val._returnval)


   def getEnabled(self):
       req=IUSBController_getEnabledRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IUSBController_getEnabled(req)
       return  Boolean(self.mgr,val._returnval)
   def setEnabled(self, value):
       req=IUSBController_setEnabledRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._enabled = value
       else:
            req._enabled = value.handle
       self.mgr.getPort().IUSBController_setEnabled(req)

   def getEnabledEhci(self):
       req=IUSBController_getEnabledEhciRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IUSBController_getEnabledEhci(req)
       return  Boolean(self.mgr,val._returnval)
   def setEnabledEhci(self, value):
       req=IUSBController_setEnabledEhciRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._enabledEhci = value
       else:
            req._enabledEhci = value.handle
       self.mgr.getPort().IUSBController_setEnabledEhci(req)

   def getProxyAvailable(self):
       req=IUSBController_getProxyAvailableRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IUSBController_getProxyAvailable(req)
       return  Boolean(self.mgr,val._returnval)
   def getUSBStandard(self):
       req=IUSBController_getUSBStandardRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IUSBController_getUSBStandard(req)
       return  UnsignedShort(self.mgr,val._returnval)
   def getDeviceFilters(self):
       req=IUSBController_getDeviceFiltersRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IUSBController_getDeviceFilters(req)
       return  IUSBDeviceFilter(self.mgr,val._returnval, True)


   _Attrs_={         'enabled':[getEnabled,setEnabled,
        ],
         'enabledEhci':[getEnabledEhci,setEnabledEhci,
        ],
         'proxyAvailable':[getProxyAvailable,None],
         'USBStandard':[getUSBStandard,None],
         'deviceFilters':[getDeviceFilters,None]}

class IUSBDevice(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IUSBDevice(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IUSBDevice._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IUSBDevice._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getId(self):
       req=IUSBDevice_getIdRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IUSBDevice_getId(req)
       return  String(self.mgr,val._returnval)
   def getVendorId(self):
       req=IUSBDevice_getVendorIdRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IUSBDevice_getVendorId(req)
       return  UnsignedShort(self.mgr,val._returnval)
   def getProductId(self):
       req=IUSBDevice_getProductIdRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IUSBDevice_getProductId(req)
       return  UnsignedShort(self.mgr,val._returnval)
   def getRevision(self):
       req=IUSBDevice_getRevisionRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IUSBDevice_getRevision(req)
       return  UnsignedShort(self.mgr,val._returnval)
   def getManufacturer(self):
       req=IUSBDevice_getManufacturerRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IUSBDevice_getManufacturer(req)
       return  String(self.mgr,val._returnval)
   def getProduct(self):
       req=IUSBDevice_getProductRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IUSBDevice_getProduct(req)
       return  String(self.mgr,val._returnval)
   def getSerialNumber(self):
       req=IUSBDevice_getSerialNumberRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IUSBDevice_getSerialNumber(req)
       return  String(self.mgr,val._returnval)
   def getAddress(self):
       req=IUSBDevice_getAddressRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IUSBDevice_getAddress(req)
       return  String(self.mgr,val._returnval)
   def getPort(self):
       req=IUSBDevice_getPortRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IUSBDevice_getPort(req)
       return  UnsignedShort(self.mgr,val._returnval)
   def getVersion(self):
       req=IUSBDevice_getVersionRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IUSBDevice_getVersion(req)
       return  UnsignedShort(self.mgr,val._returnval)
   def getPortVersion(self):
       req=IUSBDevice_getPortVersionRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IUSBDevice_getPortVersion(req)
       return  UnsignedShort(self.mgr,val._returnval)
   def getRemote(self):
       req=IUSBDevice_getRemoteRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IUSBDevice_getRemote(req)
       return  Boolean(self.mgr,val._returnval)


   _Attrs_={         'id':[getId,None],
         'vendorId':[getVendorId,None],
         'productId':[getProductId,None],
         'revision':[getRevision,None],
         'manufacturer':[getManufacturer,None],
         'product':[getProduct,None],
         'serialNumber':[getSerialNumber,None],
         'address':[getAddress,None],
         'port':[getPort,None],
         'version':[getVersion,None],
         'portVersion':[getPortVersion,None],
         'remote':[getRemote,None]}

class IUSBDeviceFilter(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IUSBDeviceFilter(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IUSBDeviceFilter._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IUSBDeviceFilter._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getName(self):
       req=IUSBDeviceFilter_getNameRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IUSBDeviceFilter_getName(req)
       return  String(self.mgr,val._returnval)
   def setName(self, value):
       req=IUSBDeviceFilter_setNameRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._name = value
       else:
            req._name = value.handle
       self.mgr.getPort().IUSBDeviceFilter_setName(req)

   def getActive(self):
       req=IUSBDeviceFilter_getActiveRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IUSBDeviceFilter_getActive(req)
       return  Boolean(self.mgr,val._returnval)
   def setActive(self, value):
       req=IUSBDeviceFilter_setActiveRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._active = value
       else:
            req._active = value.handle
       self.mgr.getPort().IUSBDeviceFilter_setActive(req)

   def getVendorId(self):
       req=IUSBDeviceFilter_getVendorIdRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IUSBDeviceFilter_getVendorId(req)
       return  String(self.mgr,val._returnval)
   def setVendorId(self, value):
       req=IUSBDeviceFilter_setVendorIdRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._vendorId = value
       else:
            req._vendorId = value.handle
       self.mgr.getPort().IUSBDeviceFilter_setVendorId(req)

   def getProductId(self):
       req=IUSBDeviceFilter_getProductIdRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IUSBDeviceFilter_getProductId(req)
       return  String(self.mgr,val._returnval)
   def setProductId(self, value):
       req=IUSBDeviceFilter_setProductIdRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._productId = value
       else:
            req._productId = value.handle
       self.mgr.getPort().IUSBDeviceFilter_setProductId(req)

   def getRevision(self):
       req=IUSBDeviceFilter_getRevisionRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IUSBDeviceFilter_getRevision(req)
       return  String(self.mgr,val._returnval)
   def setRevision(self, value):
       req=IUSBDeviceFilter_setRevisionRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._revision = value
       else:
            req._revision = value.handle
       self.mgr.getPort().IUSBDeviceFilter_setRevision(req)

   def getManufacturer(self):
       req=IUSBDeviceFilter_getManufacturerRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IUSBDeviceFilter_getManufacturer(req)
       return  String(self.mgr,val._returnval)
   def setManufacturer(self, value):
       req=IUSBDeviceFilter_setManufacturerRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._manufacturer = value
       else:
            req._manufacturer = value.handle
       self.mgr.getPort().IUSBDeviceFilter_setManufacturer(req)

   def getProduct(self):
       req=IUSBDeviceFilter_getProductRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IUSBDeviceFilter_getProduct(req)
       return  String(self.mgr,val._returnval)
   def setProduct(self, value):
       req=IUSBDeviceFilter_setProductRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._product = value
       else:
            req._product = value.handle
       self.mgr.getPort().IUSBDeviceFilter_setProduct(req)

   def getSerialNumber(self):
       req=IUSBDeviceFilter_getSerialNumberRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IUSBDeviceFilter_getSerialNumber(req)
       return  String(self.mgr,val._returnval)
   def setSerialNumber(self, value):
       req=IUSBDeviceFilter_setSerialNumberRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._serialNumber = value
       else:
            req._serialNumber = value.handle
       self.mgr.getPort().IUSBDeviceFilter_setSerialNumber(req)

   def getPort(self):
       req=IUSBDeviceFilter_getPortRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IUSBDeviceFilter_getPort(req)
       return  String(self.mgr,val._returnval)
   def setPort(self, value):
       req=IUSBDeviceFilter_setPortRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._port = value
       else:
            req._port = value.handle
       self.mgr.getPort().IUSBDeviceFilter_setPort(req)

   def getRemote(self):
       req=IUSBDeviceFilter_getRemoteRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IUSBDeviceFilter_getRemote(req)
       return  String(self.mgr,val._returnval)
   def setRemote(self, value):
       req=IUSBDeviceFilter_setRemoteRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._remote = value
       else:
            req._remote = value.handle
       self.mgr.getPort().IUSBDeviceFilter_setRemote(req)

   def getMaskedInterfaces(self):
       req=IUSBDeviceFilter_getMaskedInterfacesRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IUSBDeviceFilter_getMaskedInterfaces(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def setMaskedInterfaces(self, value):
       req=IUSBDeviceFilter_setMaskedInterfacesRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._maskedInterfaces = value
       else:
            req._maskedInterfaces = value.handle
       self.mgr.getPort().IUSBDeviceFilter_setMaskedInterfaces(req)



   _Attrs_={         'name':[getName,setName,
        ],
         'active':[getActive,setActive,
        ],
         'vendorId':[getVendorId,setVendorId,
        ],
         'productId':[getProductId,setProductId,
        ],
         'revision':[getRevision,setRevision,
        ],
         'manufacturer':[getManufacturer,setManufacturer,
        ],
         'product':[getProduct,setProduct,
        ],
         'serialNumber':[getSerialNumber,setSerialNumber,
        ],
         'port':[getPort,setPort,
        ],
         'remote':[getRemote,setRemote,
        ],
         'maskedInterfaces':[getMaskedInterfaces,setMaskedInterfaces,
        ]}

class IHostUSBDevice(IUSBDevice):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IHostUSBDevice(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IHostUSBDevice._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUSBDevice.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IHostUSBDevice._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getState(self):
       req=IHostUSBDevice_getStateRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHostUSBDevice_getState(req)
       return  USBDeviceState(self.mgr,val._returnval)


   _Attrs_={         'state':[getState,None]}

class IHostUSBDeviceFilter(IUSBDeviceFilter):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IHostUSBDeviceFilter(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IHostUSBDeviceFilter._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUSBDeviceFilter.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IHostUSBDeviceFilter._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getAction(self):
       req=IHostUSBDeviceFilter_getActionRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHostUSBDeviceFilter_getAction(req)
       return  USBDeviceFilterAction(self.mgr,val._returnval)
   def setAction(self, value):
       req=IHostUSBDeviceFilter_setActionRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._action = value
       else:
            req._action = value.handle
       self.mgr.getPort().IHostUSBDeviceFilter_setAction(req)



   _Attrs_={         'action':[getAction,setAction,
        ]}

class IAudioAdapter(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IAudioAdapter(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IAudioAdapter._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IAudioAdapter._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getEnabled(self):
       req=IAudioAdapter_getEnabledRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IAudioAdapter_getEnabled(req)
       return  Boolean(self.mgr,val._returnval)
   def setEnabled(self, value):
       req=IAudioAdapter_setEnabledRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._enabled = value
       else:
            req._enabled = value.handle
       self.mgr.getPort().IAudioAdapter_setEnabled(req)

   def getAudioController(self):
       req=IAudioAdapter_getAudioControllerRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IAudioAdapter_getAudioController(req)
       return  AudioControllerType(self.mgr,val._returnval)
   def setAudioController(self, value):
       req=IAudioAdapter_setAudioControllerRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._audioController = value
       else:
            req._audioController = value.handle
       self.mgr.getPort().IAudioAdapter_setAudioController(req)

   def getAudioDriver(self):
       req=IAudioAdapter_getAudioDriverRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IAudioAdapter_getAudioDriver(req)
       return  AudioDriverType(self.mgr,val._returnval)
   def setAudioDriver(self, value):
       req=IAudioAdapter_setAudioDriverRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._audioDriver = value
       else:
            req._audioDriver = value.handle
       self.mgr.getPort().IAudioAdapter_setAudioDriver(req)



   _Attrs_={         'enabled':[getEnabled,setEnabled,
        ],
         'audioController':[getAudioController,setAudioController,
        ],
         'audioDriver':[getAudioDriver,setAudioDriver,
        ]}

class IVRDEServer(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IVRDEServer(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IVRDEServer._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IVRDEServer._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def setVRDEProperty(self, _arg_key, _arg_value):
       req=IVRDEServer_setVRDEPropertyRequestMsg()
       req._this=self.handle
       
       req._key=_arg_key
       req._value=_arg_value
       val=self.mgr.getPort().IVRDEServer_setVRDEProperty(req)
       
       return 


   def getVRDEProperty(self, _arg_key):
       req=IVRDEServer_getVRDEPropertyRequestMsg()
       req._this=self.handle
       
       req._key=_arg_key
       val=self.mgr.getPort().IVRDEServer_getVRDEProperty(req)
       
       return String(self.mgr,val._returnval)


   def getEnabled(self):
       req=IVRDEServer_getEnabledRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVRDEServer_getEnabled(req)
       return  Boolean(self.mgr,val._returnval)
   def setEnabled(self, value):
       req=IVRDEServer_setEnabledRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._enabled = value
       else:
            req._enabled = value.handle
       self.mgr.getPort().IVRDEServer_setEnabled(req)

   def getAuthType(self):
       req=IVRDEServer_getAuthTypeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVRDEServer_getAuthType(req)
       return  AuthType(self.mgr,val._returnval)
   def setAuthType(self, value):
       req=IVRDEServer_setAuthTypeRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._authType = value
       else:
            req._authType = value.handle
       self.mgr.getPort().IVRDEServer_setAuthType(req)

   def getAuthTimeout(self):
       req=IVRDEServer_getAuthTimeoutRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVRDEServer_getAuthTimeout(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def setAuthTimeout(self, value):
       req=IVRDEServer_setAuthTimeoutRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._authTimeout = value
       else:
            req._authTimeout = value.handle
       self.mgr.getPort().IVRDEServer_setAuthTimeout(req)

   def getAllowMultiConnection(self):
       req=IVRDEServer_getAllowMultiConnectionRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVRDEServer_getAllowMultiConnection(req)
       return  Boolean(self.mgr,val._returnval)
   def setAllowMultiConnection(self, value):
       req=IVRDEServer_setAllowMultiConnectionRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._allowMultiConnection = value
       else:
            req._allowMultiConnection = value.handle
       self.mgr.getPort().IVRDEServer_setAllowMultiConnection(req)

   def getReuseSingleConnection(self):
       req=IVRDEServer_getReuseSingleConnectionRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVRDEServer_getReuseSingleConnection(req)
       return  Boolean(self.mgr,val._returnval)
   def setReuseSingleConnection(self, value):
       req=IVRDEServer_setReuseSingleConnectionRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._reuseSingleConnection = value
       else:
            req._reuseSingleConnection = value.handle
       self.mgr.getPort().IVRDEServer_setReuseSingleConnection(req)

   def getVRDEExtPack(self):
       req=IVRDEServer_getVRDEExtPackRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVRDEServer_getVRDEExtPack(req)
       return  String(self.mgr,val._returnval)
   def setVRDEExtPack(self, value):
       req=IVRDEServer_setVRDEExtPackRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._VRDEExtPack = value
       else:
            req._VRDEExtPack = value.handle
       self.mgr.getPort().IVRDEServer_setVRDEExtPack(req)

   def getAuthLibrary(self):
       req=IVRDEServer_getAuthLibraryRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVRDEServer_getAuthLibrary(req)
       return  String(self.mgr,val._returnval)
   def setAuthLibrary(self, value):
       req=IVRDEServer_setAuthLibraryRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._authLibrary = value
       else:
            req._authLibrary = value.handle
       self.mgr.getPort().IVRDEServer_setAuthLibrary(req)

   def getVRDEProperties(self):
       req=IVRDEServer_getVRDEPropertiesRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVRDEServer_getVRDEProperties(req)
       return  String(self.mgr,val._returnval, True)


   _Attrs_={         'enabled':[getEnabled,setEnabled,
        ],
         'authType':[getAuthType,setAuthType,
        ],
         'authTimeout':[getAuthTimeout,setAuthTimeout,
        ],
         'allowMultiConnection':[getAllowMultiConnection,setAllowMultiConnection,
        ],
         'reuseSingleConnection':[getReuseSingleConnection,setReuseSingleConnection,
        ],
         'VRDEExtPack':[getVRDEExtPack,setVRDEExtPack,
        ],
         'authLibrary':[getAuthLibrary,setAuthLibrary,
        ],
         'VRDEProperties':[getVRDEProperties,None]}

class ISession(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return ISession(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ISession._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ISession._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def unlockMachine(self):
       req=ISession_unlockMachineRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().ISession_unlockMachine(req)
       
       return 


   def getState(self):
       req=ISession_getStateRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISession_getState(req)
       return  SessionState(self.mgr,val._returnval)
   def getType(self):
       req=ISession_getTypeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISession_getType(req)
       return  SessionType(self.mgr,val._returnval)
   def getMachine(self):
       req=ISession_getMachineRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISession_getMachine(req)
       return  IMachine(self.mgr,val._returnval)
   def getConsole(self):
       req=ISession_getConsoleRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISession_getConsole(req)
       return  IConsole(self.mgr,val._returnval)


   _Attrs_={         'state':[getState,None],
         'type':[getType,None],
         'machine':[getMachine,None],
         'console':[getConsole,None]}

class IStorageController(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IStorageController(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IStorageController._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IStorageController._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getIDEEmulationPort(self, _arg_devicePosition):
       req=IStorageController_getIDEEmulationPortRequestMsg()
       req._this=self.handle
       
       req._devicePosition=_arg_devicePosition
       val=self.mgr.getPort().IStorageController_getIDEEmulationPort(req)
       
       return Int(self.mgr,val._returnval)


   def setIDEEmulationPort(self, _arg_devicePosition, _arg_portNumber):
       req=IStorageController_setIDEEmulationPortRequestMsg()
       req._this=self.handle
       
       req._devicePosition=_arg_devicePosition
       req._portNumber=_arg_portNumber
       val=self.mgr.getPort().IStorageController_setIDEEmulationPort(req)
       
       return 


   def getName(self):
       req=IStorageController_getNameRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IStorageController_getName(req)
       return  String(self.mgr,val._returnval)
   def getMaxDevicesPerPortCount(self):
       req=IStorageController_getMaxDevicesPerPortCountRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IStorageController_getMaxDevicesPerPortCount(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getMinPortCount(self):
       req=IStorageController_getMinPortCountRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IStorageController_getMinPortCount(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getMaxPortCount(self):
       req=IStorageController_getMaxPortCountRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IStorageController_getMaxPortCount(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getInstance(self):
       req=IStorageController_getInstanceRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IStorageController_getInstance(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def setInstance(self, value):
       req=IStorageController_setInstanceRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._instance = value
       else:
            req._instance = value.handle
       self.mgr.getPort().IStorageController_setInstance(req)

   def getPortCount(self):
       req=IStorageController_getPortCountRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IStorageController_getPortCount(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def setPortCount(self, value):
       req=IStorageController_setPortCountRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._portCount = value
       else:
            req._portCount = value.handle
       self.mgr.getPort().IStorageController_setPortCount(req)

   def getBus(self):
       req=IStorageController_getBusRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IStorageController_getBus(req)
       return  StorageBus(self.mgr,val._returnval)
   def getControllerType(self):
       req=IStorageController_getControllerTypeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IStorageController_getControllerType(req)
       return  StorageControllerType(self.mgr,val._returnval)
   def setControllerType(self, value):
       req=IStorageController_setControllerTypeRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._controllerType = value
       else:
            req._controllerType = value.handle
       self.mgr.getPort().IStorageController_setControllerType(req)

   def getUseHostIOCache(self):
       req=IStorageController_getUseHostIOCacheRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IStorageController_getUseHostIOCache(req)
       return  Boolean(self.mgr,val._returnval)
   def setUseHostIOCache(self, value):
       req=IStorageController_setUseHostIOCacheRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._useHostIOCache = value
       else:
            req._useHostIOCache = value.handle
       self.mgr.getPort().IStorageController_setUseHostIOCache(req)

   def getBootable(self):
       req=IStorageController_getBootableRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IStorageController_getBootable(req)
       return  Boolean(self.mgr,val._returnval)


   _Attrs_={         'name':[getName,None],
         'maxDevicesPerPortCount':[getMaxDevicesPerPortCount,None],
         'minPortCount':[getMinPortCount,None],
         'maxPortCount':[getMaxPortCount,None],
         'instance':[getInstance,setInstance,
        ],
         'portCount':[getPortCount,setPortCount,
        ],
         'bus':[getBus,None],
         'controllerType':[getControllerType,setControllerType,
        ],
         'useHostIOCache':[getUseHostIOCache,setUseHostIOCache,
        ],
         'bootable':[getBootable,None]}

class IManagedObjectRef(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IManagedObjectRef(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IManagedObjectRef._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IManagedObjectRef._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getInterfaceName(self):
       req=IManagedObjectRef_getInterfaceNameRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IManagedObjectRef_getInterfaceName(req)
       
       return String(self.mgr,val._returnval)


   def release(self):
       req=IManagedObjectRef_releaseRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IManagedObjectRef_release(req)
       
       return 




   _Attrs_={}

class IWebsessionManager(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IWebsessionManager(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IWebsessionManager._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IWebsessionManager._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def logon(self, _arg_username, _arg_password):
       req=IWebsessionManager_logonRequestMsg()
       req._this=self.handle
       
       req._username=_arg_username
       req._password=_arg_password
       val=self.mgr.getPort().IWebsessionManager_logon(req)
       
       return IVirtualBox(self.mgr,val._returnval)


   def getSessionObject(self, _arg_refIVirtualBox):
       req=IWebsessionManager_getSessionObjectRequestMsg()
       req._this=self.handle
       
       req._refIVirtualBox=_arg_refIVirtualBox
       val=self.mgr.getPort().IWebsessionManager_getSessionObject(req)
       
       return ISession(self.mgr,val._returnval)


   def logoff(self, _arg_refIVirtualBox):
       req=IWebsessionManager_logoffRequestMsg()
       req._this=self.handle
       
       req._refIVirtualBox=_arg_refIVirtualBox
       val=self.mgr.getPort().IWebsessionManager_logoff(req)
       
       return 




   _Attrs_={}

class IPerformanceMetric(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IPerformanceMetric(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IPerformanceMetric._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IPerformanceMetric._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getMetricName(self):
       req=IPerformanceMetric_getMetricNameRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IPerformanceMetric_getMetricName(req)
       return  String(self.mgr,val._returnval)
   def getObject(self):
       req=IPerformanceMetric_getObjectRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IPerformanceMetric_getObject(req)
       return  IUnknown(self.mgr,val._returnval)
   def getDescription(self):
       req=IPerformanceMetric_getDescriptionRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IPerformanceMetric_getDescription(req)
       return  String(self.mgr,val._returnval)
   def getPeriod(self):
       req=IPerformanceMetric_getPeriodRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IPerformanceMetric_getPeriod(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getCount(self):
       req=IPerformanceMetric_getCountRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IPerformanceMetric_getCount(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getUnit(self):
       req=IPerformanceMetric_getUnitRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IPerformanceMetric_getUnit(req)
       return  String(self.mgr,val._returnval)
   def getMinimumValue(self):
       req=IPerformanceMetric_getMinimumValueRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IPerformanceMetric_getMinimumValue(req)
       return  Int(self.mgr,val._returnval)
   def getMaximumValue(self):
       req=IPerformanceMetric_getMaximumValueRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IPerformanceMetric_getMaximumValue(req)
       return  Int(self.mgr,val._returnval)


   _Attrs_={         'metricName':[getMetricName,None],
         'object':[getObject,None],
         'description':[getDescription,None],
         'period':[getPeriod,None],
         'count':[getCount,None],
         'unit':[getUnit,None],
         'minimumValue':[getMinimumValue,None],
         'maximumValue':[getMaximumValue,None]}

class IPerformanceCollector(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IPerformanceCollector(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IPerformanceCollector._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IPerformanceCollector._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getMetrics(self, _arg_metricNames, _arg_objects):
       req=IPerformanceCollector_getMetricsRequestMsg()
       req._this=self.handle
       
       req._metricNames=_arg_metricNames
       req._objects=_arg_objects
       val=self.mgr.getPort().IPerformanceCollector_getMetrics(req)
       
       return IPerformanceMetric(self.mgr,val._returnval, True)


   def setupMetrics(self, _arg_metricNames, _arg_objects, _arg_period, _arg_count):
       req=IPerformanceCollector_setupMetricsRequestMsg()
       req._this=self.handle
       
       req._metricNames=_arg_metricNames
       req._objects=_arg_objects
       req._period=_arg_period
       req._count=_arg_count
       val=self.mgr.getPort().IPerformanceCollector_setupMetrics(req)
       
       return IPerformanceMetric(self.mgr,val._returnval, True)


   def enableMetrics(self, _arg_metricNames, _arg_objects):
       req=IPerformanceCollector_enableMetricsRequestMsg()
       req._this=self.handle
       
       req._metricNames=_arg_metricNames
       req._objects=_arg_objects
       val=self.mgr.getPort().IPerformanceCollector_enableMetrics(req)
       
       return IPerformanceMetric(self.mgr,val._returnval, True)


   def disableMetrics(self, _arg_metricNames, _arg_objects):
       req=IPerformanceCollector_disableMetricsRequestMsg()
       req._this=self.handle
       
       req._metricNames=_arg_metricNames
       req._objects=_arg_objects
       val=self.mgr.getPort().IPerformanceCollector_disableMetrics(req)
       
       return IPerformanceMetric(self.mgr,val._returnval, True)


   def queryMetricsData(self, _arg_metricNames, _arg_objects):
       req=IPerformanceCollector_queryMetricsDataRequestMsg()
       req._this=self.handle
       
       req._metricNames=_arg_metricNames
       req._objects=_arg_objects
       val=self.mgr.getPort().IPerformanceCollector_queryMetricsData(req)
       
       return Int(self.mgr,val._returnval, True), String(self.mgr,val._returnMetricNames, True), IUnknown(self.mgr,val._returnObjects, True), String(self.mgr,val._returnUnits, True), UnsignedInt(self.mgr,val._returnScales, True), UnsignedInt(self.mgr,val._returnSequenceNumbers, True), UnsignedInt(self.mgr,val._returnDataIndices, True), UnsignedInt(self.mgr,val._returnDataLengths, True)


   def getMetricNames(self):
       req=IPerformanceCollector_getMetricNamesRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IPerformanceCollector_getMetricNames(req)
       return  String(self.mgr,val._returnval, True)


   _Attrs_={         'metricNames':[getMetricNames,None]}

class INATEngine(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return INATEngine(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = INATEngine._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = INATEngine._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def setNetworkSettings(self, _arg_mtu, _arg_sockSnd, _arg_sockRcv, _arg_TcpWndSnd, _arg_TcpWndRcv):
       req=INATEngine_setNetworkSettingsRequestMsg()
       req._this=self.handle
       
       req._mtu=_arg_mtu
       req._sockSnd=_arg_sockSnd
       req._sockRcv=_arg_sockRcv
       req._TcpWndSnd=_arg_TcpWndSnd
       req._TcpWndRcv=_arg_TcpWndRcv
       val=self.mgr.getPort().INATEngine_setNetworkSettings(req)
       
       return 


   def getNetworkSettings(self):
       req=INATEngine_getNetworkSettingsRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().INATEngine_getNetworkSettings(req)
       
       return UnsignedInt(self.mgr,val._mtu), UnsignedInt(self.mgr,val._sockSnd), UnsignedInt(self.mgr,val._sockRcv), UnsignedInt(self.mgr,val._TcpWndSnd), UnsignedInt(self.mgr,val._TcpWndRcv)


   def addRedirect(self, _arg_name, _arg_proto, _arg_hostIp, _arg_hostPort, _arg_guestIp, _arg_guestPort):
       req=INATEngine_addRedirectRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       req._proto=_arg_proto
       req._hostIp=_arg_hostIp
       req._hostPort=_arg_hostPort
       req._guestIp=_arg_guestIp
       req._guestPort=_arg_guestPort
       val=self.mgr.getPort().INATEngine_addRedirect(req)
       
       return 


   def removeRedirect(self, _arg_name):
       req=INATEngine_removeRedirectRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       val=self.mgr.getPort().INATEngine_removeRedirect(req)
       
       return 


   def getNetwork(self):
       req=INATEngine_getNetworkRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INATEngine_getNetwork(req)
       return  String(self.mgr,val._returnval)
   def setNetwork(self, value):
       req=INATEngine_setNetworkRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._network = value
       else:
            req._network = value.handle
       self.mgr.getPort().INATEngine_setNetwork(req)

   def getHostIP(self):
       req=INATEngine_getHostIPRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INATEngine_getHostIP(req)
       return  String(self.mgr,val._returnval)
   def setHostIP(self, value):
       req=INATEngine_setHostIPRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._hostIP = value
       else:
            req._hostIP = value.handle
       self.mgr.getPort().INATEngine_setHostIP(req)

   def getTftpPrefix(self):
       req=INATEngine_getTftpPrefixRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INATEngine_getTftpPrefix(req)
       return  String(self.mgr,val._returnval)
   def setTftpPrefix(self, value):
       req=INATEngine_setTftpPrefixRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._tftpPrefix = value
       else:
            req._tftpPrefix = value.handle
       self.mgr.getPort().INATEngine_setTftpPrefix(req)

   def getTftpBootFile(self):
       req=INATEngine_getTftpBootFileRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INATEngine_getTftpBootFile(req)
       return  String(self.mgr,val._returnval)
   def setTftpBootFile(self, value):
       req=INATEngine_setTftpBootFileRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._tftpBootFile = value
       else:
            req._tftpBootFile = value.handle
       self.mgr.getPort().INATEngine_setTftpBootFile(req)

   def getTftpNextServer(self):
       req=INATEngine_getTftpNextServerRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INATEngine_getTftpNextServer(req)
       return  String(self.mgr,val._returnval)
   def setTftpNextServer(self, value):
       req=INATEngine_setTftpNextServerRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._tftpNextServer = value
       else:
            req._tftpNextServer = value.handle
       self.mgr.getPort().INATEngine_setTftpNextServer(req)

   def getAliasMode(self):
       req=INATEngine_getAliasModeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INATEngine_getAliasMode(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def setAliasMode(self, value):
       req=INATEngine_setAliasModeRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._aliasMode = value
       else:
            req._aliasMode = value.handle
       self.mgr.getPort().INATEngine_setAliasMode(req)

   def getDnsPassDomain(self):
       req=INATEngine_getDnsPassDomainRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INATEngine_getDnsPassDomain(req)
       return  Boolean(self.mgr,val._returnval)
   def setDnsPassDomain(self, value):
       req=INATEngine_setDnsPassDomainRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._dnsPassDomain = value
       else:
            req._dnsPassDomain = value.handle
       self.mgr.getPort().INATEngine_setDnsPassDomain(req)

   def getDnsProxy(self):
       req=INATEngine_getDnsProxyRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INATEngine_getDnsProxy(req)
       return  Boolean(self.mgr,val._returnval)
   def setDnsProxy(self, value):
       req=INATEngine_setDnsProxyRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._dnsProxy = value
       else:
            req._dnsProxy = value.handle
       self.mgr.getPort().INATEngine_setDnsProxy(req)

   def getDnsUseHostResolver(self):
       req=INATEngine_getDnsUseHostResolverRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INATEngine_getDnsUseHostResolver(req)
       return  Boolean(self.mgr,val._returnval)
   def setDnsUseHostResolver(self, value):
       req=INATEngine_setDnsUseHostResolverRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._dnsUseHostResolver = value
       else:
            req._dnsUseHostResolver = value.handle
       self.mgr.getPort().INATEngine_setDnsUseHostResolver(req)

   def getRedirects(self):
       req=INATEngine_getRedirectsRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INATEngine_getRedirects(req)
       return  String(self.mgr,val._returnval, True)


   _Attrs_={         'network':[getNetwork,setNetwork,
        ],
         'hostIP':[getHostIP,setHostIP,
        ],
         'tftpPrefix':[getTftpPrefix,setTftpPrefix,
        ],
         'tftpBootFile':[getTftpBootFile,setTftpBootFile,
        ],
         'tftpNextServer':[getTftpNextServer,setTftpNextServer,
        ],
         'aliasMode':[getAliasMode,setAliasMode,
        ],
         'dnsPassDomain':[getDnsPassDomain,setDnsPassDomain,
        ],
         'dnsProxy':[getDnsProxy,setDnsProxy,
        ],
         'dnsUseHostResolver':[getDnsUseHostResolver,setDnsUseHostResolver,
        ],
         'redirects':[getRedirects,None]}

class IBandwidthGroup(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IBandwidthGroup(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IBandwidthGroup._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IBandwidthGroup._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getName(self):
       req=IBandwidthGroup_getNameRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IBandwidthGroup_getName(req)
       return  String(self.mgr,val._returnval)
   def getType(self):
       req=IBandwidthGroup_getTypeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IBandwidthGroup_getType(req)
       return  BandwidthGroupType(self.mgr,val._returnval)
   def getReference(self):
       req=IBandwidthGroup_getReferenceRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IBandwidthGroup_getReference(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getMaxMbPerSec(self):
       req=IBandwidthGroup_getMaxMbPerSecRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IBandwidthGroup_getMaxMbPerSec(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def setMaxMbPerSec(self, value):
       req=IBandwidthGroup_setMaxMbPerSecRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._maxMbPerSec = value
       else:
            req._maxMbPerSec = value.handle
       self.mgr.getPort().IBandwidthGroup_setMaxMbPerSec(req)



   _Attrs_={         'name':[getName,None],
         'type':[getType,None],
         'reference':[getReference,None],
         'maxMbPerSec':[getMaxMbPerSec,setMaxMbPerSec,
        ]}

class IBandwidthControl(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IBandwidthControl(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IBandwidthControl._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IBandwidthControl._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def createBandwidthGroup(self, _arg_name, _arg_type, _arg_maxMbPerSec):
       req=IBandwidthControl_createBandwidthGroupRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       req._type=_arg_type
       req._maxMbPerSec=_arg_maxMbPerSec
       val=self.mgr.getPort().IBandwidthControl_createBandwidthGroup(req)
       
       return 


   def deleteBandwidthGroup(self, _arg_name):
       req=IBandwidthControl_deleteBandwidthGroupRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       val=self.mgr.getPort().IBandwidthControl_deleteBandwidthGroup(req)
       
       return 


   def getBandwidthGroup(self, _arg_name):
       req=IBandwidthControl_getBandwidthGroupRequestMsg()
       req._this=self.handle
       
       req._name=_arg_name
       val=self.mgr.getPort().IBandwidthControl_getBandwidthGroup(req)
       
       return IBandwidthGroup(self.mgr,val._returnval)


   def getAllBandwidthGroups(self):
       req=IBandwidthControl_getAllBandwidthGroupsRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IBandwidthControl_getAllBandwidthGroups(req)
       
       return IBandwidthGroup(self.mgr,val._returnval, True)


   def getNumGroups(self):
       req=IBandwidthControl_getNumGroupsRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IBandwidthControl_getNumGroups(req)
       return  UnsignedInt(self.mgr,val._returnval)


   _Attrs_={         'numGroups':[getNumGroups,None]}

class IEventSource(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IEventSource(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IEventSource._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IEventSource._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def createListener(self):
       req=IEventSource_createListenerRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IEventSource_createListener(req)
       
       return IEventListener(self.mgr,val._returnval)


   def createAggregator(self, _arg_subordinates):
       req=IEventSource_createAggregatorRequestMsg()
       req._this=self.handle
       
       req._subordinates=_arg_subordinates
       val=self.mgr.getPort().IEventSource_createAggregator(req)
       
       return IEventSource(self.mgr,val._returnval)


   def registerListener(self, _arg_listener, _arg_interesting, _arg_active):
       req=IEventSource_registerListenerRequestMsg()
       req._this=self.handle
       
       req._listener=_arg_listener
       req._interesting=_arg_interesting
       req._active=_arg_active
       val=self.mgr.getPort().IEventSource_registerListener(req)
       
       return 


   def unregisterListener(self, _arg_listener):
       req=IEventSource_unregisterListenerRequestMsg()
       req._this=self.handle
       
       req._listener=_arg_listener
       val=self.mgr.getPort().IEventSource_unregisterListener(req)
       
       return 


   def fireEvent(self, _arg_event, _arg_timeout):
       req=IEventSource_fireEventRequestMsg()
       req._this=self.handle
       
       req._event=_arg_event
       req._timeout=_arg_timeout
       val=self.mgr.getPort().IEventSource_fireEvent(req)
       
       return Boolean(self.mgr,val._returnval)


   def getEvent(self, _arg_listener, _arg_timeout):
       req=IEventSource_getEventRequestMsg()
       req._this=self.handle
       
       req._listener=_arg_listener
       req._timeout=_arg_timeout
       val=self.mgr.getPort().IEventSource_getEvent(req)
       
       return IEvent(self.mgr,val._returnval)


   def eventProcessed(self, _arg_listener, _arg_event):
       req=IEventSource_eventProcessedRequestMsg()
       req._this=self.handle
       
       req._listener=_arg_listener
       req._event=_arg_event
       val=self.mgr.getPort().IEventSource_eventProcessed(req)
       
       return 




   _Attrs_={}

class IEventListener(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IEventListener(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IEventListener._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IEventListener._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def handleEvent(self, _arg_event):
       req=IEventListener_handleEventRequestMsg()
       req._this=self.handle
       
       req._event=_arg_event
       val=self.mgr.getPort().IEventListener_handleEvent(req)
       
       return 




   _Attrs_={}

class IEvent(IUnknown):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IUnknown.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def setProcessed(self):
       req=IEvent_setProcessedRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IEvent_setProcessed(req)
       
       return 


   def waitProcessed(self, _arg_timeout):
       req=IEvent_waitProcessedRequestMsg()
       req._this=self.handle
       
       req._timeout=_arg_timeout
       val=self.mgr.getPort().IEvent_waitProcessed(req)
       
       return Boolean(self.mgr,val._returnval)


   def getType(self):
       req=IEvent_getTypeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IEvent_getType(req)
       return  VBoxEventType(self.mgr,val._returnval)
   def getSource(self):
       req=IEvent_getSourceRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IEvent_getSource(req)
       return  IEventSource(self.mgr,val._returnval)
   def getWaitable(self):
       req=IEvent_getWaitableRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IEvent_getWaitable(req)
       return  Boolean(self.mgr,val._returnval)


   _Attrs_={         'type':[getType,None],
         'source':[getSource,None],
         'waitable':[getWaitable,None]}

class IReusableEvent(IEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IReusableEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IReusableEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IReusableEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def reuse(self):
       req=IReusableEvent_reuseRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IReusableEvent_reuse(req)
       
       return 


   def getGeneration(self):
       req=IReusableEvent_getGenerationRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IReusableEvent_getGeneration(req)
       return  UnsignedInt(self.mgr,val._returnval)


   _Attrs_={         'generation':[getGeneration,None]}

class IMachineEvent(IEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IMachineEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IMachineEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IMachineEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getMachineId(self):
       req=IMachineEvent_getMachineIdRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachineEvent_getMachineId(req)
       return  String(self.mgr,val._returnval)


   _Attrs_={         'machineId':[getMachineId,None]}

class IMachineStateChangedEvent(IMachineEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IMachineStateChangedEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IMachineStateChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IMachineEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IMachineStateChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getState(self):
       req=IMachineStateChangedEvent_getStateRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachineStateChangedEvent_getState(req)
       return  MachineState(self.mgr,val._returnval)


   _Attrs_={         'state':[getState,None]}

class IMachineDataChangedEvent(IMachineEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IMachineDataChangedEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IMachineDataChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IMachineEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IMachineDataChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getTemporary(self):
       req=IMachineDataChangedEvent_getTemporaryRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachineDataChangedEvent_getTemporary(req)
       return  Boolean(self.mgr,val._returnval)


   _Attrs_={         'temporary':[getTemporary,None]}

class IMediumRegisteredEvent(IEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IMediumRegisteredEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IMediumRegisteredEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IMediumRegisteredEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getMediumId(self):
       req=IMediumRegisteredEvent_getMediumIdRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMediumRegisteredEvent_getMediumId(req)
       return  String(self.mgr,val._returnval)
   def getMediumType(self):
       req=IMediumRegisteredEvent_getMediumTypeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMediumRegisteredEvent_getMediumType(req)
       return  DeviceType(self.mgr,val._returnval)
   def getRegistered(self):
       req=IMediumRegisteredEvent_getRegisteredRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMediumRegisteredEvent_getRegistered(req)
       return  Boolean(self.mgr,val._returnval)


   _Attrs_={         'mediumId':[getMediumId,None],
         'mediumType':[getMediumType,None],
         'registered':[getRegistered,None]}

class IMachineRegisteredEvent(IMachineEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IMachineRegisteredEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IMachineRegisteredEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IMachineEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IMachineRegisteredEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getRegistered(self):
       req=IMachineRegisteredEvent_getRegisteredRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMachineRegisteredEvent_getRegistered(req)
       return  Boolean(self.mgr,val._returnval)


   _Attrs_={         'registered':[getRegistered,None]}

class ISessionStateChangedEvent(IMachineEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return ISessionStateChangedEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ISessionStateChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IMachineEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ISessionStateChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getState(self):
       req=ISessionStateChangedEvent_getStateRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISessionStateChangedEvent_getState(req)
       return  SessionState(self.mgr,val._returnval)


   _Attrs_={         'state':[getState,None]}

class IGuestPropertyChangedEvent(IMachineEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IGuestPropertyChangedEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestPropertyChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IMachineEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestPropertyChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getName(self):
       req=IGuestPropertyChangedEvent_getNameRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IGuestPropertyChangedEvent_getName(req)
       return  String(self.mgr,val._returnval)
   def getValue(self):
       req=IGuestPropertyChangedEvent_getValueRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IGuestPropertyChangedEvent_getValue(req)
       return  String(self.mgr,val._returnval)
   def getFlags(self):
       req=IGuestPropertyChangedEvent_getFlagsRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IGuestPropertyChangedEvent_getFlags(req)
       return  String(self.mgr,val._returnval)


   _Attrs_={         'name':[getName,None],
         'value':[getValue,None],
         'flags':[getFlags,None]}

class ISnapshotEvent(IMachineEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return ISnapshotEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ISnapshotEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IMachineEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ISnapshotEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getSnapshotId(self):
       req=ISnapshotEvent_getSnapshotIdRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISnapshotEvent_getSnapshotId(req)
       return  String(self.mgr,val._returnval)


   _Attrs_={         'snapshotId':[getSnapshotId,None]}

class ISnapshotTakenEvent(ISnapshotEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return ISnapshotTakenEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ISnapshotTakenEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return ISnapshotEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ISnapshotTakenEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   


   _Attrs_={}

class ISnapshotDeletedEvent(ISnapshotEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return ISnapshotDeletedEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ISnapshotDeletedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return ISnapshotEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ISnapshotDeletedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   


   _Attrs_={}

class ISnapshotChangedEvent(ISnapshotEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return ISnapshotChangedEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ISnapshotChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return ISnapshotEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ISnapshotChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   


   _Attrs_={}

class IMousePointerShapeChangedEvent(IEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IMousePointerShapeChangedEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IMousePointerShapeChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IMousePointerShapeChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getVisible(self):
       req=IMousePointerShapeChangedEvent_getVisibleRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMousePointerShapeChangedEvent_getVisible(req)
       return  Boolean(self.mgr,val._returnval)
   def getAlpha(self):
       req=IMousePointerShapeChangedEvent_getAlphaRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMousePointerShapeChangedEvent_getAlpha(req)
       return  Boolean(self.mgr,val._returnval)
   def getXhot(self):
       req=IMousePointerShapeChangedEvent_getXhotRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMousePointerShapeChangedEvent_getXhot(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getYhot(self):
       req=IMousePointerShapeChangedEvent_getYhotRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMousePointerShapeChangedEvent_getYhot(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getWidth(self):
       req=IMousePointerShapeChangedEvent_getWidthRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMousePointerShapeChangedEvent_getWidth(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getHeight(self):
       req=IMousePointerShapeChangedEvent_getHeightRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMousePointerShapeChangedEvent_getHeight(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getShape(self):
       req=IMousePointerShapeChangedEvent_getShapeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMousePointerShapeChangedEvent_getShape(req)
       return  self.mgr.decodebase64(val._returnval)


   _Attrs_={         'visible':[getVisible,None],
         'alpha':[getAlpha,None],
         'xhot':[getXhot,None],
         'yhot':[getYhot,None],
         'width':[getWidth,None],
         'height':[getHeight,None],
         'shape':[getShape,None]}

class IMouseCapabilityChangedEvent(IEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IMouseCapabilityChangedEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IMouseCapabilityChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IMouseCapabilityChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getSupportsAbsolute(self):
       req=IMouseCapabilityChangedEvent_getSupportsAbsoluteRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMouseCapabilityChangedEvent_getSupportsAbsolute(req)
       return  Boolean(self.mgr,val._returnval)
   def getSupportsRelative(self):
       req=IMouseCapabilityChangedEvent_getSupportsRelativeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMouseCapabilityChangedEvent_getSupportsRelative(req)
       return  Boolean(self.mgr,val._returnval)
   def getNeedsHostCursor(self):
       req=IMouseCapabilityChangedEvent_getNeedsHostCursorRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMouseCapabilityChangedEvent_getNeedsHostCursor(req)
       return  Boolean(self.mgr,val._returnval)


   _Attrs_={         'supportsAbsolute':[getSupportsAbsolute,None],
         'supportsRelative':[getSupportsRelative,None],
         'needsHostCursor':[getNeedsHostCursor,None]}

class IKeyboardLedsChangedEvent(IEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IKeyboardLedsChangedEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IKeyboardLedsChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IKeyboardLedsChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getNumLock(self):
       req=IKeyboardLedsChangedEvent_getNumLockRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IKeyboardLedsChangedEvent_getNumLock(req)
       return  Boolean(self.mgr,val._returnval)
   def getCapsLock(self):
       req=IKeyboardLedsChangedEvent_getCapsLockRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IKeyboardLedsChangedEvent_getCapsLock(req)
       return  Boolean(self.mgr,val._returnval)
   def getScrollLock(self):
       req=IKeyboardLedsChangedEvent_getScrollLockRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IKeyboardLedsChangedEvent_getScrollLock(req)
       return  Boolean(self.mgr,val._returnval)


   _Attrs_={         'numLock':[getNumLock,None],
         'capsLock':[getCapsLock,None],
         'scrollLock':[getScrollLock,None]}

class IStateChangedEvent(IEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IStateChangedEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IStateChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IStateChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getState(self):
       req=IStateChangedEvent_getStateRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IStateChangedEvent_getState(req)
       return  MachineState(self.mgr,val._returnval)


   _Attrs_={         'state':[getState,None]}

class IAdditionsStateChangedEvent(IEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IAdditionsStateChangedEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IAdditionsStateChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IAdditionsStateChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   


   _Attrs_={}

class INetworkAdapterChangedEvent(IEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return INetworkAdapterChangedEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = INetworkAdapterChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = INetworkAdapterChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getNetworkAdapter(self):
       req=INetworkAdapterChangedEvent_getNetworkAdapterRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INetworkAdapterChangedEvent_getNetworkAdapter(req)
       return  INetworkAdapter(self.mgr,val._returnval)


   _Attrs_={         'networkAdapter':[getNetworkAdapter,None]}

class ISerialPortChangedEvent(IEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return ISerialPortChangedEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ISerialPortChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ISerialPortChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getSerialPort(self):
       req=ISerialPortChangedEvent_getSerialPortRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISerialPortChangedEvent_getSerialPort(req)
       return  ISerialPort(self.mgr,val._returnval)


   _Attrs_={         'serialPort':[getSerialPort,None]}

class IParallelPortChangedEvent(IEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IParallelPortChangedEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IParallelPortChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IParallelPortChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getParallelPort(self):
       req=IParallelPortChangedEvent_getParallelPortRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IParallelPortChangedEvent_getParallelPort(req)
       return  IParallelPort(self.mgr,val._returnval)


   _Attrs_={         'parallelPort':[getParallelPort,None]}

class IStorageControllerChangedEvent(IEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IStorageControllerChangedEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IStorageControllerChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IStorageControllerChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   


   _Attrs_={}

class IMediumChangedEvent(IEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IMediumChangedEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IMediumChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IMediumChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getMediumAttachment(self):
       req=IMediumChangedEvent_getMediumAttachmentRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IMediumChangedEvent_getMediumAttachment(req)
       return  IMediumAttachment(self.mgr,val._returnval)


   _Attrs_={         'mediumAttachment':[getMediumAttachment,None]}

class ICPUChangedEvent(IEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return ICPUChangedEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ICPUChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ICPUChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getCpu(self):
       req=ICPUChangedEvent_getCpuRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ICPUChangedEvent_getCpu(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getAdd(self):
       req=ICPUChangedEvent_getAddRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ICPUChangedEvent_getAdd(req)
       return  Boolean(self.mgr,val._returnval)


   _Attrs_={         'cpu':[getCpu,None],
         'add':[getAdd,None]}

class ICPUExecutionCapChangedEvent(IEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return ICPUExecutionCapChangedEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ICPUExecutionCapChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ICPUExecutionCapChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getExecutionCap(self):
       req=ICPUExecutionCapChangedEvent_getExecutionCapRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ICPUExecutionCapChangedEvent_getExecutionCap(req)
       return  UnsignedInt(self.mgr,val._returnval)


   _Attrs_={         'executionCap':[getExecutionCap,None]}

class IGuestKeyboardEvent(IEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IGuestKeyboardEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestKeyboardEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestKeyboardEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getScancodes(self):
       req=IGuestKeyboardEvent_getScancodesRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IGuestKeyboardEvent_getScancodes(req)
       return  Int(self.mgr,val._returnval, True)


   _Attrs_={         'scancodes':[getScancodes,None]}

class IGuestMouseEvent(IReusableEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IGuestMouseEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestMouseEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IReusableEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestMouseEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getAbsolute(self):
       req=IGuestMouseEvent_getAbsoluteRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IGuestMouseEvent_getAbsolute(req)
       return  Boolean(self.mgr,val._returnval)
   def getX(self):
       req=IGuestMouseEvent_getXRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IGuestMouseEvent_getX(req)
       return  Int(self.mgr,val._returnval)
   def getY(self):
       req=IGuestMouseEvent_getYRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IGuestMouseEvent_getY(req)
       return  Int(self.mgr,val._returnval)
   def getZ(self):
       req=IGuestMouseEvent_getZRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IGuestMouseEvent_getZ(req)
       return  Int(self.mgr,val._returnval)
   def getW(self):
       req=IGuestMouseEvent_getWRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IGuestMouseEvent_getW(req)
       return  Int(self.mgr,val._returnval)
   def getButtons(self):
       req=IGuestMouseEvent_getButtonsRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IGuestMouseEvent_getButtons(req)
       return  Int(self.mgr,val._returnval)


   _Attrs_={         'absolute':[getAbsolute,None],
         'x':[getX,None],
         'y':[getY,None],
         'z':[getZ,None],
         'w':[getW,None],
         'buttons':[getButtons,None]}

class IVRDEServerChangedEvent(IEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IVRDEServerChangedEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IVRDEServerChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IVRDEServerChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   


   _Attrs_={}

class IVRDEServerInfoChangedEvent(IEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IVRDEServerInfoChangedEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IVRDEServerInfoChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IVRDEServerInfoChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   


   _Attrs_={}

class IUSBControllerChangedEvent(IEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IUSBControllerChangedEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IUSBControllerChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IUSBControllerChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   


   _Attrs_={}

class IUSBDeviceStateChangedEvent(IEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IUSBDeviceStateChangedEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IUSBDeviceStateChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IUSBDeviceStateChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getDevice(self):
       req=IUSBDeviceStateChangedEvent_getDeviceRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IUSBDeviceStateChangedEvent_getDevice(req)
       return  IUSBDevice(self.mgr,val._returnval)
   def getAttached(self):
       req=IUSBDeviceStateChangedEvent_getAttachedRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IUSBDeviceStateChangedEvent_getAttached(req)
       return  Boolean(self.mgr,val._returnval)
   def getError(self):
       req=IUSBDeviceStateChangedEvent_getErrorRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IUSBDeviceStateChangedEvent_getError(req)
       return  IVirtualBoxErrorInfo(self.mgr,val._returnval)


   _Attrs_={         'device':[getDevice,None],
         'attached':[getAttached,None],
         'error':[getError,None]}

class ISharedFolderChangedEvent(IEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return ISharedFolderChangedEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ISharedFolderChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ISharedFolderChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getScope(self):
       req=ISharedFolderChangedEvent_getScopeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().ISharedFolderChangedEvent_getScope(req)
       return  Scope(self.mgr,val._returnval)


   _Attrs_={         'scope':[getScope,None]}

class IRuntimeErrorEvent(IEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IRuntimeErrorEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IRuntimeErrorEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IRuntimeErrorEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getFatal(self):
       req=IRuntimeErrorEvent_getFatalRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IRuntimeErrorEvent_getFatal(req)
       return  Boolean(self.mgr,val._returnval)
   def getId(self):
       req=IRuntimeErrorEvent_getIdRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IRuntimeErrorEvent_getId(req)
       return  String(self.mgr,val._returnval)
   def getMessage(self):
       req=IRuntimeErrorEvent_getMessageRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IRuntimeErrorEvent_getMessage(req)
       return  String(self.mgr,val._returnval)


   _Attrs_={         'fatal':[getFatal,None],
         'id':[getId,None],
         'message':[getMessage,None]}

class IEventSourceChangedEvent(IEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IEventSourceChangedEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IEventSourceChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IEventSourceChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getListener(self):
       req=IEventSourceChangedEvent_getListenerRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IEventSourceChangedEvent_getListener(req)
       return  IEventListener(self.mgr,val._returnval)
   def getAdd(self):
       req=IEventSourceChangedEvent_getAddRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IEventSourceChangedEvent_getAdd(req)
       return  Boolean(self.mgr,val._returnval)


   _Attrs_={         'listener':[getListener,None],
         'add':[getAdd,None]}

class IExtraDataChangedEvent(IEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IExtraDataChangedEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IExtraDataChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IExtraDataChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getMachineId(self):
       req=IExtraDataChangedEvent_getMachineIdRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IExtraDataChangedEvent_getMachineId(req)
       return  String(self.mgr,val._returnval)
   def getKey(self):
       req=IExtraDataChangedEvent_getKeyRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IExtraDataChangedEvent_getKey(req)
       return  String(self.mgr,val._returnval)
   def getValue(self):
       req=IExtraDataChangedEvent_getValueRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IExtraDataChangedEvent_getValue(req)
       return  String(self.mgr,val._returnval)


   _Attrs_={         'machineId':[getMachineId,None],
         'key':[getKey,None],
         'value':[getValue,None]}

class IVetoEvent(IEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IVetoEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IVetoEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IVetoEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def addVeto(self, _arg_reason):
       req=IVetoEvent_addVetoRequestMsg()
       req._this=self.handle
       
       req._reason=_arg_reason
       val=self.mgr.getPort().IVetoEvent_addVeto(req)
       
       return 


   def isVetoed(self):
       req=IVetoEvent_isVetoedRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IVetoEvent_isVetoed(req)
       
       return Boolean(self.mgr,val._returnval)


   def getVetos(self):
       req=IVetoEvent_getVetosRequestMsg()
       req._this=self.handle
       
       val=self.mgr.getPort().IVetoEvent_getVetos(req)
       
       return String(self.mgr,val._returnval, True)




   _Attrs_={}

class IExtraDataCanChangeEvent(IVetoEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IExtraDataCanChangeEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IExtraDataCanChangeEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IVetoEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IExtraDataCanChangeEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getMachineId(self):
       req=IExtraDataCanChangeEvent_getMachineIdRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IExtraDataCanChangeEvent_getMachineId(req)
       return  String(self.mgr,val._returnval)
   def getKey(self):
       req=IExtraDataCanChangeEvent_getKeyRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IExtraDataCanChangeEvent_getKey(req)
       return  String(self.mgr,val._returnval)
   def getValue(self):
       req=IExtraDataCanChangeEvent_getValueRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IExtraDataCanChangeEvent_getValue(req)
       return  String(self.mgr,val._returnval)


   _Attrs_={         'machineId':[getMachineId,None],
         'key':[getKey,None],
         'value':[getValue,None]}

class ICanShowWindowEvent(IVetoEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return ICanShowWindowEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = ICanShowWindowEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IVetoEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = ICanShowWindowEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   


   _Attrs_={}

class IShowWindowEvent(IEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IShowWindowEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IShowWindowEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IShowWindowEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getWinId(self):
       req=IShowWindowEvent_getWinIdRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IShowWindowEvent_getWinId(req)
       return  Long(self.mgr,val._returnval)
   def setWinId(self, value):
       req=IShowWindowEvent_setWinIdRequestMsg()
       req._this=self.handle
       if type(value) in [int, bool, basestring, str]:
            req._winId = value
       else:
            req._winId = value.handle
       self.mgr.getPort().IShowWindowEvent_setWinId(req)



   _Attrs_={         'winId':[getWinId,setWinId,
        ]}

class INATRedirectEvent(IMachineEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return INATRedirectEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = INATRedirectEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IMachineEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = INATRedirectEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getSlot(self):
       req=INATRedirectEvent_getSlotRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INATRedirectEvent_getSlot(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getRemove(self):
       req=INATRedirectEvent_getRemoveRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INATRedirectEvent_getRemove(req)
       return  Boolean(self.mgr,val._returnval)
   def getName(self):
       req=INATRedirectEvent_getNameRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INATRedirectEvent_getName(req)
       return  String(self.mgr,val._returnval)
   def getProto(self):
       req=INATRedirectEvent_getProtoRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INATRedirectEvent_getProto(req)
       return  NATProtocol(self.mgr,val._returnval)
   def getHostIp(self):
       req=INATRedirectEvent_getHostIpRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INATRedirectEvent_getHostIp(req)
       return  String(self.mgr,val._returnval)
   def getHostPort(self):
       req=INATRedirectEvent_getHostPortRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INATRedirectEvent_getHostPort(req)
       return  Int(self.mgr,val._returnval)
   def getGuestIp(self):
       req=INATRedirectEvent_getGuestIpRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INATRedirectEvent_getGuestIp(req)
       return  String(self.mgr,val._returnval)
   def getGuestPort(self):
       req=INATRedirectEvent_getGuestPortRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().INATRedirectEvent_getGuestPort(req)
       return  Int(self.mgr,val._returnval)


   _Attrs_={         'slot':[getSlot,None],
         'remove':[getRemove,None],
         'name':[getName,None],
         'proto':[getProto,None],
         'hostIp':[getHostIp,None],
         'hostPort':[getHostPort,None],
         'guestIp':[getGuestIp,None],
         'guestPort':[getGuestPort,None]}

class IHostPciDevicePlugEvent(IMachineEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IHostPciDevicePlugEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IHostPciDevicePlugEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IMachineEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IHostPciDevicePlugEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getPlugged(self):
       req=IHostPciDevicePlugEvent_getPluggedRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHostPciDevicePlugEvent_getPlugged(req)
       return  Boolean(self.mgr,val._returnval)
   def getSuccess(self):
       req=IHostPciDevicePlugEvent_getSuccessRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHostPciDevicePlugEvent_getSuccess(req)
       return  Boolean(self.mgr,val._returnval)
   def getAttachment(self):
       req=IHostPciDevicePlugEvent_getAttachmentRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHostPciDevicePlugEvent_getAttachment(req)
       return  IPciDeviceAttachment(self.mgr,val._returnval)
   def getMessage(self):
       req=IHostPciDevicePlugEvent_getMessageRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IHostPciDevicePlugEvent_getMessage(req)
       return  String(self.mgr,val._returnval)


   _Attrs_={         'plugged':[getPlugged,None],
         'success':[getSuccess,None],
         'attachment':[getAttachment,None],
         'message':[getMessage,None]}

class IVBoxSVCAvailabilityChangedEvent(IEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IVBoxSVCAvailabilityChangedEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IVBoxSVCAvailabilityChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IVBoxSVCAvailabilityChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getAvailable(self):
       req=IVBoxSVCAvailabilityChangedEvent_getAvailableRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IVBoxSVCAvailabilityChangedEvent_getAvailable(req)
       return  Boolean(self.mgr,val._returnval)


   _Attrs_={         'available':[getAvailable,None]}

class IBandwidthGroupChangedEvent(IEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IBandwidthGroupChangedEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IBandwidthGroupChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IBandwidthGroupChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getBandwidthGroup(self):
       req=IBandwidthGroupChangedEvent_getBandwidthGroupRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IBandwidthGroupChangedEvent_getBandwidthGroup(req)
       return  IBandwidthGroup(self.mgr,val._returnval)


   _Attrs_={         'bandwidthGroup':[getBandwidthGroup,None]}

class IGuestMonitorChangedEvent(IEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IGuestMonitorChangedEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IGuestMonitorChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IGuestMonitorChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getChangeType(self):
       req=IGuestMonitorChangedEvent_getChangeTypeRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IGuestMonitorChangedEvent_getChangeType(req)
       return  GuestMonitorChangedEventType(self.mgr,val._returnval)
   def getScreenId(self):
       req=IGuestMonitorChangedEvent_getScreenIdRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IGuestMonitorChangedEvent_getScreenId(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getOriginX(self):
       req=IGuestMonitorChangedEvent_getOriginXRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IGuestMonitorChangedEvent_getOriginX(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getOriginY(self):
       req=IGuestMonitorChangedEvent_getOriginYRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IGuestMonitorChangedEvent_getOriginY(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getWidth(self):
       req=IGuestMonitorChangedEvent_getWidthRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IGuestMonitorChangedEvent_getWidth(req)
       return  UnsignedInt(self.mgr,val._returnval)
   def getHeight(self):
       req=IGuestMonitorChangedEvent_getHeightRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IGuestMonitorChangedEvent_getHeight(req)
       return  UnsignedInt(self.mgr,val._returnval)


   _Attrs_={         'changeType':[getChangeType,None],
         'screenId':[getScreenId,None],
         'originX':[getOriginX,None],
         'originY':[getOriginY,None],
         'width':[getWidth,None],
         'height':[getHeight,None]}

class IStorageDeviceChangedEvent(IEvent):
   def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       if handle is None:
           raise Exception("bad handle: "+str(handle))
       self.handle = handle
       self.isarray = isarray

   def releaseRemote(self):
        try:
            req=IManagedObjectRef_releaseRequestMsg()
            req._this=handle
            self.mgr.getPort().IManagedObjectRef_release(req)
        except:
            pass

   def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

   def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

   def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

   def __getitem__(self, index):
      if self.isarray:
          return IStorageDeviceChangedEvent(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"

   def __str__(self):
        return self.handle

   def isValid(self):
        return self.handle != None and self.handle != ''

   def __getattr__(self,name):
      hndl = IStorageDeviceChangedEvent._Attrs_.get(name, None)
      if hndl != None:
         if hndl[0] != None:
           return hndl[0](self)
         else:
          raise AttributeError
      else:
         return IEvent.__getattr__(self, name)

   def __setattr__(self, name, val):
      hndl = IStorageDeviceChangedEvent._Attrs_.get(name, None)
      if (hndl != None and hndl[1] != None):
         hndl[1](self,val)
      else:
         self.__dict__[name] = val

   
   def getStorageDevice(self):
       req=IStorageDeviceChangedEvent_getStorageDeviceRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IStorageDeviceChangedEvent_getStorageDevice(req)
       return  IMediumAttachment(self.mgr,val._returnval)
   def getRemoved(self):
       req=IStorageDeviceChangedEvent_getRemovedRequestMsg()
       req._this=self.handle
       val=self.mgr.getPort().IStorageDeviceChangedEvent_getRemoved(req)
       return  Boolean(self.mgr,val._returnval)


   _Attrs_={         'storageDevice':[getStorageDevice,None],
         'removed':[getRemoved,None]}
class IPciAddress:
    def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       self.isarray = isarray
       if isarray:
          self.handle = handle
       else:

          self.bus = Short(self.mgr, handle._bus)
       
          self.device = Short(self.mgr, handle._device)
       
          self.devFunction = Short(self.mgr, handle._devFunction)
       
          pass

   
    def getBus(self):
       return self.bus

    def setBus(self):
       raise Error, 'setters not supported'
    
    def getDevice(self):
       return self.device

    def setDevice(self):
       raise Error, 'setters not supported'
    
    def getDevFunction(self):
       return self.devFunction

    def setDevFunction(self):
       raise Error, 'setters not supported'
    

    def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

    def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

    def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

    def __getitem__(self, index):
      if self.isarray:
          return IPciAddress(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"


class IPciDeviceAttachment:
    def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       self.isarray = isarray
       if isarray:
          self.handle = handle
       else:

          self.name = String(self.mgr, handle._name)
       
          self.isPhysicalDevice = Boolean(self.mgr, handle._isPhysicalDevice)
       
          self.hostAddress = Int(self.mgr, handle._hostAddress)
       
          self.guestAddress = Int(self.mgr, handle._guestAddress)
       
          pass

   
    def getName(self):
       return self.name

    def setName(self):
       raise Error, 'setters not supported'
    
    def getIsPhysicalDevice(self):
       return self.isPhysicalDevice

    def setIsPhysicalDevice(self):
       raise Error, 'setters not supported'
    
    def getHostAddress(self):
       return self.hostAddress

    def setHostAddress(self):
       raise Error, 'setters not supported'
    
    def getGuestAddress(self):
       return self.guestAddress

    def setGuestAddress(self):
       raise Error, 'setters not supported'
    

    def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

    def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

    def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

    def __getitem__(self, index):
      if self.isarray:
          return IPciDeviceAttachment(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"


class IVRDEServerInfo:
    def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       self.isarray = isarray
       if isarray:
          self.handle = handle
       else:

          self.active = Boolean(self.mgr, handle._active)
       
          self.port = Int(self.mgr, handle._port)
       
          self.numberOfClients = UnsignedInt(self.mgr, handle._numberOfClients)
       
          self.beginTime = Long(self.mgr, handle._beginTime)
       
          self.endTime = Long(self.mgr, handle._endTime)
       
          self.bytesSent = Long(self.mgr, handle._bytesSent)
       
          self.bytesSentTotal = Long(self.mgr, handle._bytesSentTotal)
       
          self.bytesReceived = Long(self.mgr, handle._bytesReceived)
       
          self.bytesReceivedTotal = Long(self.mgr, handle._bytesReceivedTotal)
       
          self.user = String(self.mgr, handle._user)
       
          self.domain = String(self.mgr, handle._domain)
       
          self.clientName = String(self.mgr, handle._clientName)
       
          self.clientIP = String(self.mgr, handle._clientIP)
       
          self.clientVersion = UnsignedInt(self.mgr, handle._clientVersion)
       
          self.encryptionStyle = UnsignedInt(self.mgr, handle._encryptionStyle)
       
          pass

   
    def getActive(self):
       return self.active

    def setActive(self):
       raise Error, 'setters not supported'
    
    def getPort(self):
       return self.port

    def setPort(self):
       raise Error, 'setters not supported'
    
    def getNumberOfClients(self):
       return self.numberOfClients

    def setNumberOfClients(self):
       raise Error, 'setters not supported'
    
    def getBeginTime(self):
       return self.beginTime

    def setBeginTime(self):
       raise Error, 'setters not supported'
    
    def getEndTime(self):
       return self.endTime

    def setEndTime(self):
       raise Error, 'setters not supported'
    
    def getBytesSent(self):
       return self.bytesSent

    def setBytesSent(self):
       raise Error, 'setters not supported'
    
    def getBytesSentTotal(self):
       return self.bytesSentTotal

    def setBytesSentTotal(self):
       raise Error, 'setters not supported'
    
    def getBytesReceived(self):
       return self.bytesReceived

    def setBytesReceived(self):
       raise Error, 'setters not supported'
    
    def getBytesReceivedTotal(self):
       return self.bytesReceivedTotal

    def setBytesReceivedTotal(self):
       raise Error, 'setters not supported'
    
    def getUser(self):
       return self.user

    def setUser(self):
       raise Error, 'setters not supported'
    
    def getDomain(self):
       return self.domain

    def setDomain(self):
       raise Error, 'setters not supported'
    
    def getClientName(self):
       return self.clientName

    def setClientName(self):
       raise Error, 'setters not supported'
    
    def getClientIP(self):
       return self.clientIP

    def setClientIP(self):
       raise Error, 'setters not supported'
    
    def getClientVersion(self):
       return self.clientVersion

    def setClientVersion(self):
       raise Error, 'setters not supported'
    
    def getEncryptionStyle(self):
       return self.encryptionStyle

    def setEncryptionStyle(self):
       raise Error, 'setters not supported'
    

    def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

    def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

    def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

    def __getitem__(self, index):
      if self.isarray:
          return IVRDEServerInfo(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"


class IGuestOSType:
    def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       self.isarray = isarray
       if isarray:
          self.handle = handle
       else:

          self.familyId = String(self.mgr, handle._familyId)
       
          self.familyDescription = String(self.mgr, handle._familyDescription)
       
          self.id = String(self.mgr, handle._id)
       
          self.description = String(self.mgr, handle._description)
       
          self.is64Bit = Boolean(self.mgr, handle._is64Bit)
       
          self.recommendedIOAPIC = Boolean(self.mgr, handle._recommendedIOAPIC)
       
          self.recommendedVirtEx = Boolean(self.mgr, handle._recommendedVirtEx)
       
          self.recommendedRAM = UnsignedInt(self.mgr, handle._recommendedRAM)
       
          self.recommendedVRAM = UnsignedInt(self.mgr, handle._recommendedVRAM)
       
          self.recommendedHDD = Long(self.mgr, handle._recommendedHDD)
       
          self.adapterType = NetworkAdapterType(self.mgr, handle._adapterType)
       
          self.recommendedPae = Boolean(self.mgr, handle._recommendedPae)
       
          self.recommendedDvdStorageController = StorageControllerType(self.mgr, handle._recommendedDvdStorageController)
       
          self.recommendedDvdStorageBus = StorageBus(self.mgr, handle._recommendedDvdStorageBus)
       
          self.recommendedHdStorageController = StorageControllerType(self.mgr, handle._recommendedHdStorageController)
       
          self.recommendedHdStorageBus = StorageBus(self.mgr, handle._recommendedHdStorageBus)
       
          self.recommendedFirmware = FirmwareType(self.mgr, handle._recommendedFirmware)
       
          self.recommendedUsbHid = Boolean(self.mgr, handle._recommendedUsbHid)
       
          self.recommendedHpet = Boolean(self.mgr, handle._recommendedHpet)
       
          self.recommendedUsbTablet = Boolean(self.mgr, handle._recommendedUsbTablet)
       
          self.recommendedRtcUseUtc = Boolean(self.mgr, handle._recommendedRtcUseUtc)
       
          self.recommendedChipset = ChipsetType(self.mgr, handle._recommendedChipset)
       
          self.recommendedAudioController = AudioControllerType(self.mgr, handle._recommendedAudioController)
       
          pass

   
    def getFamilyId(self):
       return self.familyId

    def setFamilyId(self):
       raise Error, 'setters not supported'
    
    def getFamilyDescription(self):
       return self.familyDescription

    def setFamilyDescription(self):
       raise Error, 'setters not supported'
    
    def getId(self):
       return self.id

    def setId(self):
       raise Error, 'setters not supported'
    
    def getDescription(self):
       return self.description

    def setDescription(self):
       raise Error, 'setters not supported'
    
    def getIs64Bit(self):
       return self.is64Bit

    def setIs64Bit(self):
       raise Error, 'setters not supported'
    
    def getRecommendedIOAPIC(self):
       return self.recommendedIOAPIC

    def setRecommendedIOAPIC(self):
       raise Error, 'setters not supported'
    
    def getRecommendedVirtEx(self):
       return self.recommendedVirtEx

    def setRecommendedVirtEx(self):
       raise Error, 'setters not supported'
    
    def getRecommendedRAM(self):
       return self.recommendedRAM

    def setRecommendedRAM(self):
       raise Error, 'setters not supported'
    
    def getRecommendedVRAM(self):
       return self.recommendedVRAM

    def setRecommendedVRAM(self):
       raise Error, 'setters not supported'
    
    def getRecommendedHDD(self):
       return self.recommendedHDD

    def setRecommendedHDD(self):
       raise Error, 'setters not supported'
    
    def getAdapterType(self):
       return self.adapterType

    def setAdapterType(self):
       raise Error, 'setters not supported'
    
    def getRecommendedPae(self):
       return self.recommendedPae

    def setRecommendedPae(self):
       raise Error, 'setters not supported'
    
    def getRecommendedDvdStorageController(self):
       return self.recommendedDvdStorageController

    def setRecommendedDvdStorageController(self):
       raise Error, 'setters not supported'
    
    def getRecommendedDvdStorageBus(self):
       return self.recommendedDvdStorageBus

    def setRecommendedDvdStorageBus(self):
       raise Error, 'setters not supported'
    
    def getRecommendedHdStorageController(self):
       return self.recommendedHdStorageController

    def setRecommendedHdStorageController(self):
       raise Error, 'setters not supported'
    
    def getRecommendedHdStorageBus(self):
       return self.recommendedHdStorageBus

    def setRecommendedHdStorageBus(self):
       raise Error, 'setters not supported'
    
    def getRecommendedFirmware(self):
       return self.recommendedFirmware

    def setRecommendedFirmware(self):
       raise Error, 'setters not supported'
    
    def getRecommendedUsbHid(self):
       return self.recommendedUsbHid

    def setRecommendedUsbHid(self):
       raise Error, 'setters not supported'
    
    def getRecommendedHpet(self):
       return self.recommendedHpet

    def setRecommendedHpet(self):
       raise Error, 'setters not supported'
    
    def getRecommendedUsbTablet(self):
       return self.recommendedUsbTablet

    def setRecommendedUsbTablet(self):
       raise Error, 'setters not supported'
    
    def getRecommendedRtcUseUtc(self):
       return self.recommendedRtcUseUtc

    def setRecommendedRtcUseUtc(self):
       raise Error, 'setters not supported'
    
    def getRecommendedChipset(self):
       return self.recommendedChipset

    def setRecommendedChipset(self):
       raise Error, 'setters not supported'
    
    def getRecommendedAudioController(self):
       return self.recommendedAudioController

    def setRecommendedAudioController(self):
       raise Error, 'setters not supported'
    

    def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

    def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

    def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

    def __getitem__(self, index):
      if self.isarray:
          return IGuestOSType(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"


class IAdditionsFacility:
    def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       self.isarray = isarray
       if isarray:
          self.handle = handle
       else:

          self.classType = AdditionsFacilityClass(self.mgr, handle._classType)
       
          self.lastUpdated = Long(self.mgr, handle._lastUpdated)
       
          self.name = String(self.mgr, handle._name)
       
          self.status = AdditionsFacilityStatus(self.mgr, handle._status)
       
          self.type = AdditionsFacilityType(self.mgr, handle._type)
       
          pass

   
    def getClassType(self):
       return self.classType

    def setClassType(self):
       raise Error, 'setters not supported'
    
    def getLastUpdated(self):
       return self.lastUpdated

    def setLastUpdated(self):
       raise Error, 'setters not supported'
    
    def getName(self):
       return self.name

    def setName(self):
       raise Error, 'setters not supported'
    
    def getStatus(self):
       return self.status

    def setStatus(self):
       raise Error, 'setters not supported'
    
    def getType(self):
       return self.type

    def setType(self):
       raise Error, 'setters not supported'
    

    def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

    def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

    def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

    def __getitem__(self, index):
      if self.isarray:
          return IAdditionsFacility(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"


class IGuestDirEntry:
    def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       self.isarray = isarray
       if isarray:
          self.handle = handle
       else:

          self.nodeId = Long(self.mgr, handle._nodeId)
       
          self.name = String(self.mgr, handle._name)
       
          self.type = GuestDirEntryType(self.mgr, handle._type)
       
          pass

   
    def getNodeId(self):
       return self.nodeId

    def setNodeId(self):
       raise Error, 'setters not supported'
    
    def getName(self):
       return self.name

    def setName(self):
       raise Error, 'setters not supported'
    
    def getType(self):
       return self.type

    def setType(self):
       raise Error, 'setters not supported'
    

    def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

    def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

    def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

    def __getitem__(self, index):
      if self.isarray:
          return IGuestDirEntry(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"


class IMediumAttachment:
    def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       self.isarray = isarray
       if isarray:
          self.handle = handle
       else:

          self.medium = IMedium(self.mgr, handle._medium)
       
          self.controller = String(self.mgr, handle._controller)
       
          self.port = Int(self.mgr, handle._port)
       
          self.device = Int(self.mgr, handle._device)
       
          self.type = DeviceType(self.mgr, handle._type)
       
          self.passthrough = Boolean(self.mgr, handle._passthrough)
       
          self.temporaryEject = Boolean(self.mgr, handle._temporaryEject)
       
          self.isEjected = Boolean(self.mgr, handle._isEjected)
       
          self.nonRotational = Boolean(self.mgr, handle._nonRotational)
       
          self.bandwidthGroup = IBandwidthGroup(self.mgr, handle._bandwidthGroup)
       
          pass

   
    def getMedium(self):
       return self.medium

    def setMedium(self):
       raise Error, 'setters not supported'
    
    def getController(self):
       return self.controller

    def setController(self):
       raise Error, 'setters not supported'
    
    def getPort(self):
       return self.port

    def setPort(self):
       raise Error, 'setters not supported'
    
    def getDevice(self):
       return self.device

    def setDevice(self):
       raise Error, 'setters not supported'
    
    def getType(self):
       return self.type

    def setType(self):
       raise Error, 'setters not supported'
    
    def getPassthrough(self):
       return self.passthrough

    def setPassthrough(self):
       raise Error, 'setters not supported'
    
    def getTemporaryEject(self):
       return self.temporaryEject

    def setTemporaryEject(self):
       raise Error, 'setters not supported'
    
    def getIsEjected(self):
       return self.isEjected

    def setIsEjected(self):
       raise Error, 'setters not supported'
    
    def getNonRotational(self):
       return self.nonRotational

    def setNonRotational(self):
       raise Error, 'setters not supported'
    
    def getBandwidthGroup(self):
       return self.bandwidthGroup

    def setBandwidthGroup(self):
       raise Error, 'setters not supported'
    

    def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

    def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

    def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

    def __getitem__(self, index):
      if self.isarray:
          return IMediumAttachment(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"


class ISharedFolder:
    def __init__(self, mgr, handle, isarray = False):
       self.mgr = mgr
       self.isarray = isarray
       if isarray:
          self.handle = handle
       else:

          self.name = String(self.mgr, handle._name)
       
          self.hostPath = String(self.mgr, handle._hostPath)
       
          self.accessible = Boolean(self.mgr, handle._accessible)
       
          self.writable = Boolean(self.mgr, handle._writable)
       
          self.autoMount = Boolean(self.mgr, handle._autoMount)
       
          self.lastAccessError = String(self.mgr, handle._lastAccessError)
       
          pass

   
    def getName(self):
       return self.name

    def setName(self):
       raise Error, 'setters not supported'
    
    def getHostPath(self):
       return self.hostPath

    def setHostPath(self):
       raise Error, 'setters not supported'
    
    def getAccessible(self):
       return self.accessible

    def setAccessible(self):
       raise Error, 'setters not supported'
    
    def getWritable(self):
       return self.writable

    def setWritable(self):
       raise Error, 'setters not supported'
    
    def getAutoMount(self):
       return self.autoMount

    def setAutoMount(self):
       raise Error, 'setters not supported'
    
    def getLastAccessError(self):
       return self.lastAccessError

    def setLastAccessError(self):
       raise Error, 'setters not supported'
    

    def __next(self):
      if self.isarray:
          return self.handle.__next()
      raise TypeError, "iteration over non-sequence"

    def __size(self):
      if self.isarray:
          return self.handle.__size()
      raise TypeError, "iteration over non-sequence"

    def __len__(self):
      if self.isarray:
          return self.handle.__len__()
      raise TypeError, "iteration over non-sequence"

    def __getitem__(self, index):
      if self.isarray:
          return ISharedFolder(self.mgr, self.handle[index])
      raise TypeError, "iteration over non-sequence"


class SettingsVersion:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=SettingsVersion._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,SettingsVersion):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,SettingsVersion):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return SettingsVersion._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Null',1:'v1_0',2:'v1_1',3:'v1_2',4:'v1_3pre',5:'v1_3',6:'v1_4',7:'v1_5',8:'v1_6',9:'v1_7',10:'v1_8',11:'v1_9',12:'v1_10',13:'v1_11',14:'v1_12',99999:'Future'}
   _ValueMap={
              'Null':0,
              'v1_0':1,
              'v1_1':2,
              'v1_2':3,
              'v1_3pre':4,
              'v1_3':5,
              'v1_4':6,
              'v1_5':7,
              'v1_6':8,
              'v1_7':9,
              'v1_8':10,
              'v1_9':11,
              'v1_10':12,
              'v1_11':13,
              'v1_12':14,
              'Future':99999}

   Null=0
   v1_0=1
   v1_1=2
   v1_2=3
   v1_3pre=4
   v1_3=5
   v1_4=6
   v1_5=7
   v1_6=8
   v1_7=9
   v1_8=10
   v1_9=11
   v1_10=12
   v1_11=13
   v1_12=14
   Future=99999

class AccessMode:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=AccessMode._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,AccessMode):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,AccessMode):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return AccessMode._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={1:'ReadOnly',2:'ReadWrite'}
   _ValueMap={
              'ReadOnly':1,
              'ReadWrite':2}

   ReadOnly=1
   ReadWrite=2

class MachineState:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=MachineState._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,MachineState):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,MachineState):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return MachineState._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Null',1:'PoweredOff',2:'Saved',3:'Teleported',4:'Aborted',5:'Running',6:'Paused',7:'Stuck',8:'Teleporting',9:'LiveSnapshotting',10:'Starting',11:'Stopping',12:'Saving',13:'Restoring',14:'TeleportingPausedVM',15:'TeleportingIn',16:'FaultTolerantSyncing',17:'DeletingSnapshotOnline',18:'DeletingSnapshotPaused',19:'RestoringSnapshot',20:'DeletingSnapshot',21:'SettingUp',5:'FirstOnline',18:'LastOnline',8:'FirstTransient',21:'LastTransient'}
   _ValueMap={
              'Null':0,
              'PoweredOff':1,
              'Saved':2,
              'Teleported':3,
              'Aborted':4,
              'Running':5,
              'Paused':6,
              'Stuck':7,
              'Teleporting':8,
              'LiveSnapshotting':9,
              'Starting':10,
              'Stopping':11,
              'Saving':12,
              'Restoring':13,
              'TeleportingPausedVM':14,
              'TeleportingIn':15,
              'FaultTolerantSyncing':16,
              'DeletingSnapshotOnline':17,
              'DeletingSnapshotPaused':18,
              'RestoringSnapshot':19,
              'DeletingSnapshot':20,
              'SettingUp':21,
              'FirstOnline':5,
              'LastOnline':18,
              'FirstTransient':8,
              'LastTransient':21}

   Null=0
   PoweredOff=1
   Saved=2
   Teleported=3
   Aborted=4
   Running=5
   Paused=6
   Stuck=7
   Teleporting=8
   LiveSnapshotting=9
   Starting=10
   Stopping=11
   Saving=12
   Restoring=13
   TeleportingPausedVM=14
   TeleportingIn=15
   FaultTolerantSyncing=16
   DeletingSnapshotOnline=17
   DeletingSnapshotPaused=18
   RestoringSnapshot=19
   DeletingSnapshot=20
   SettingUp=21
   FirstOnline=5
   LastOnline=18
   FirstTransient=8
   LastTransient=21

class SessionState:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=SessionState._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,SessionState):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,SessionState):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return SessionState._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Null',1:'Unlocked',2:'Locked',3:'Spawning',4:'Unlocking'}
   _ValueMap={
              'Null':0,
              'Unlocked':1,
              'Locked':2,
              'Spawning':3,
              'Unlocking':4}

   Null=0
   Unlocked=1
   Locked=2
   Spawning=3
   Unlocking=4

class CPUPropertyType:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=CPUPropertyType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,CPUPropertyType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,CPUPropertyType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return CPUPropertyType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Null',1:'PAE',2:'Synthetic'}
   _ValueMap={
              'Null':0,
              'PAE':1,
              'Synthetic':2}

   Null=0
   PAE=1
   Synthetic=2

class HWVirtExPropertyType:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=HWVirtExPropertyType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,HWVirtExPropertyType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,HWVirtExPropertyType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return HWVirtExPropertyType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Null',1:'Enabled',2:'Exclusive',3:'VPID',4:'NestedPaging',5:'LargePages',6:'Force'}
   _ValueMap={
              'Null':0,
              'Enabled':1,
              'Exclusive':2,
              'VPID':3,
              'NestedPaging':4,
              'LargePages':5,
              'Force':6}

   Null=0
   Enabled=1
   Exclusive=2
   VPID=3
   NestedPaging=4
   LargePages=5
   Force=6

class FaultToleranceState:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=FaultToleranceState._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,FaultToleranceState):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,FaultToleranceState):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return FaultToleranceState._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={1:'Inactive',2:'Master',3:'Standby'}
   _ValueMap={
              'Inactive':1,
              'Master':2,
              'Standby':3}

   Inactive=1
   Master=2
   Standby=3

class LockType:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=LockType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,LockType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,LockType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return LockType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={2:'Write',1:'Shared'}
   _ValueMap={
              'Write':2,
              'Shared':1}

   Write=2
   Shared=1

class SessionType:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=SessionType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,SessionType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,SessionType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return SessionType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Null',1:'WriteLock',2:'Remote',3:'Shared'}
   _ValueMap={
              'Null':0,
              'WriteLock':1,
              'Remote':2,
              'Shared':3}

   Null=0
   WriteLock=1
   Remote=2
   Shared=3

class DeviceType:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=DeviceType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,DeviceType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,DeviceType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return DeviceType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Null',1:'Floppy',2:'DVD',3:'HardDisk',4:'Network',5:'USB',6:'SharedFolder'}
   _ValueMap={
              'Null':0,
              'Floppy':1,
              'DVD':2,
              'HardDisk':3,
              'Network':4,
              'USB':5,
              'SharedFolder':6}

   Null=0
   Floppy=1
   DVD=2
   HardDisk=3
   Network=4
   USB=5
   SharedFolder=6

class DeviceActivity:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=DeviceActivity._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,DeviceActivity):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,DeviceActivity):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return DeviceActivity._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Null',1:'Idle',2:'Reading',3:'Writing'}
   _ValueMap={
              'Null':0,
              'Idle':1,
              'Reading':2,
              'Writing':3}

   Null=0
   Idle=1
   Reading=2
   Writing=3

class ClipboardMode:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=ClipboardMode._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,ClipboardMode):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,ClipboardMode):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return ClipboardMode._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Disabled',1:'HostToGuest',2:'GuestToHost',3:'Bidirectional'}
   _ValueMap={
              'Disabled':0,
              'HostToGuest':1,
              'GuestToHost':2,
              'Bidirectional':3}

   Disabled=0
   HostToGuest=1
   GuestToHost=2
   Bidirectional=3

class Scope:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=Scope._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,Scope):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,Scope):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return Scope._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Global',1:'Machine',2:'Session'}
   _ValueMap={
              'Global':0,
              'Machine':1,
              'Session':2}

   Global=0
   Machine=1
   Session=2

class BIOSBootMenuMode:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=BIOSBootMenuMode._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,BIOSBootMenuMode):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,BIOSBootMenuMode):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return BIOSBootMenuMode._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Disabled',1:'MenuOnly',2:'MessageAndMenu'}
   _ValueMap={
              'Disabled':0,
              'MenuOnly':1,
              'MessageAndMenu':2}

   Disabled=0
   MenuOnly=1
   MessageAndMenu=2

class ProcessorFeature:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=ProcessorFeature._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,ProcessorFeature):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,ProcessorFeature):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return ProcessorFeature._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'HWVirtEx',1:'PAE',2:'LongMode',3:'NestedPaging'}
   _ValueMap={
              'HWVirtEx':0,
              'PAE':1,
              'LongMode':2,
              'NestedPaging':3}

   HWVirtEx=0
   PAE=1
   LongMode=2
   NestedPaging=3

class FirmwareType:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=FirmwareType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,FirmwareType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,FirmwareType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return FirmwareType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={1:'BIOS',2:'EFI',3:'EFI32',4:'EFI64',5:'EFIDUAL'}
   _ValueMap={
              'BIOS':1,
              'EFI':2,
              'EFI32':3,
              'EFI64':4,
              'EFIDUAL':5}

   BIOS=1
   EFI=2
   EFI32=3
   EFI64=4
   EFIDUAL=5

class PointingHidType:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=PointingHidType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,PointingHidType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,PointingHidType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return PointingHidType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={1:'None',2:'PS2Mouse',3:'USBMouse',4:'USBTablet',5:'ComboMouse'}
   _ValueMap={
              'None':1,
              'PS2Mouse':2,
              'USBMouse':3,
              'USBTablet':4,
              'ComboMouse':5}

   _None=1
   PS2Mouse=2
   USBMouse=3
   USBTablet=4
   ComboMouse=5

class KeyboardHidType:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=KeyboardHidType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,KeyboardHidType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,KeyboardHidType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return KeyboardHidType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={1:'None',2:'PS2Keyboard',3:'USBKeyboard',4:'ComboKeyboard'}
   _ValueMap={
              'None':1,
              'PS2Keyboard':2,
              'USBKeyboard':3,
              'ComboKeyboard':4}

   _None=1
   PS2Keyboard=2
   USBKeyboard=3
   ComboKeyboard=4

class VFSType:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=VFSType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,VFSType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,VFSType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return VFSType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={1:'File',2:'Cloud',3:'S3',4:'WebDav'}
   _ValueMap={
              'File':1,
              'Cloud':2,
              'S3':3,
              'WebDav':4}

   File=1
   Cloud=2
   S3=3
   WebDav=4

class VFSFileType:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=VFSFileType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,VFSFileType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,VFSFileType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return VFSFileType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={1:'Unknown',2:'Fifo',3:'DevChar',4:'Directory',5:'DevBlock',6:'File',7:'SymLink',8:'Socket',9:'WhiteOut'}
   _ValueMap={
              'Unknown':1,
              'Fifo':2,
              'DevChar':3,
              'Directory':4,
              'DevBlock':5,
              'File':6,
              'SymLink':7,
              'Socket':8,
              'WhiteOut':9}

   Unknown=1
   Fifo=2
   DevChar=3
   Directory=4
   DevBlock=5
   File=6
   SymLink=7
   Socket=8
   WhiteOut=9

class ImportOptions:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=ImportOptions._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,ImportOptions):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,ImportOptions):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return ImportOptions._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={1:'KeepAllMACs',2:'KeepNATMACs'}
   _ValueMap={
              'KeepAllMACs':1,
              'KeepNATMACs':2}

   KeepAllMACs=1
   KeepNATMACs=2

class VirtualSystemDescriptionType:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=VirtualSystemDescriptionType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,VirtualSystemDescriptionType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,VirtualSystemDescriptionType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return VirtualSystemDescriptionType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={1:'Ignore',2:'OS',3:'Name',4:'Product',5:'Vendor',6:'Version',7:'ProductUrl',8:'VendorUrl',9:'Description',10:'License',11:'Miscellaneous',12:'CPU',13:'Memory',14:'HardDiskControllerIDE',15:'HardDiskControllerSATA',16:'HardDiskControllerSCSI',17:'HardDiskControllerSAS',18:'HardDiskImage',19:'Floppy',20:'CDROM',21:'NetworkAdapter',22:'USBController',23:'SoundCard',24:'SettingsFile'}
   _ValueMap={
              'Ignore':1,
              'OS':2,
              'Name':3,
              'Product':4,
              'Vendor':5,
              'Version':6,
              'ProductUrl':7,
              'VendorUrl':8,
              'Description':9,
              'License':10,
              'Miscellaneous':11,
              'CPU':12,
              'Memory':13,
              'HardDiskControllerIDE':14,
              'HardDiskControllerSATA':15,
              'HardDiskControllerSCSI':16,
              'HardDiskControllerSAS':17,
              'HardDiskImage':18,
              'Floppy':19,
              'CDROM':20,
              'NetworkAdapter':21,
              'USBController':22,
              'SoundCard':23,
              'SettingsFile':24}

   Ignore=1
   OS=2
   Name=3
   Product=4
   Vendor=5
   Version=6
   ProductUrl=7
   VendorUrl=8
   Description=9
   License=10
   Miscellaneous=11
   CPU=12
   Memory=13
   HardDiskControllerIDE=14
   HardDiskControllerSATA=15
   HardDiskControllerSCSI=16
   HardDiskControllerSAS=17
   HardDiskImage=18
   Floppy=19
   CDROM=20
   NetworkAdapter=21
   USBController=22
   SoundCard=23
   SettingsFile=24

class VirtualSystemDescriptionValueType:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=VirtualSystemDescriptionValueType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,VirtualSystemDescriptionValueType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,VirtualSystemDescriptionValueType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return VirtualSystemDescriptionValueType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={1:'Reference',2:'Original',3:'Auto',4:'ExtraConfig'}
   _ValueMap={
              'Reference':1,
              'Original':2,
              'Auto':3,
              'ExtraConfig':4}

   Reference=1
   Original=2
   Auto=3
   ExtraConfig=4

class CleanupMode:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=CleanupMode._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,CleanupMode):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,CleanupMode):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return CleanupMode._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={1:'UnregisterOnly',2:'DetachAllReturnNone',3:'DetachAllReturnHardDisksOnly',4:'Full'}
   _ValueMap={
              'UnregisterOnly':1,
              'DetachAllReturnNone':2,
              'DetachAllReturnHardDisksOnly':3,
              'Full':4}

   UnregisterOnly=1
   DetachAllReturnNone=2
   DetachAllReturnHardDisksOnly=3
   Full=4

class CloneMode:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=CloneMode._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,CloneMode):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,CloneMode):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return CloneMode._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={1:'MachineState',2:'MachineAndChildStates',3:'AllStates'}
   _ValueMap={
              'MachineState':1,
              'MachineAndChildStates':2,
              'AllStates':3}

   MachineState=1
   MachineAndChildStates=2
   AllStates=3

class CloneOptions:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=CloneOptions._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,CloneOptions):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,CloneOptions):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return CloneOptions._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={1:'Link',2:'KeepAllMACs',3:'KeepNATMACs',4:'KeepDiskNames'}
   _ValueMap={
              'Link':1,
              'KeepAllMACs':2,
              'KeepNATMACs':3,
              'KeepDiskNames':4}

   Link=1
   KeepAllMACs=2
   KeepNATMACs=3
   KeepDiskNames=4

class HostNetworkInterfaceMediumType:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=HostNetworkInterfaceMediumType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,HostNetworkInterfaceMediumType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,HostNetworkInterfaceMediumType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return HostNetworkInterfaceMediumType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Unknown',1:'Ethernet',2:'PPP',3:'SLIP'}
   _ValueMap={
              'Unknown':0,
              'Ethernet':1,
              'PPP':2,
              'SLIP':3}

   Unknown=0
   Ethernet=1
   PPP=2
   SLIP=3

class HostNetworkInterfaceStatus:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=HostNetworkInterfaceStatus._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,HostNetworkInterfaceStatus):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,HostNetworkInterfaceStatus):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return HostNetworkInterfaceStatus._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Unknown',1:'Up',2:'Down'}
   _ValueMap={
              'Unknown':0,
              'Up':1,
              'Down':2}

   Unknown=0
   Up=1
   Down=2

class HostNetworkInterfaceType:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=HostNetworkInterfaceType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,HostNetworkInterfaceType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,HostNetworkInterfaceType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return HostNetworkInterfaceType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={1:'Bridged',2:'HostOnly'}
   _ValueMap={
              'Bridged':1,
              'HostOnly':2}

   Bridged=1
   HostOnly=2

class AdditionsFacilityType:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=AdditionsFacilityType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,AdditionsFacilityType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,AdditionsFacilityType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return AdditionsFacilityType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'None',20:'VBoxGuestDriver',100:'VBoxService',101:'VBoxTrayClient',1000:'Seamless',1100:'Graphics',2147483646:'All'}
   _ValueMap={
              'None':0,
              'VBoxGuestDriver':20,
              'VBoxService':100,
              'VBoxTrayClient':101,
              'Seamless':1000,
              'Graphics':1100,
              'All':2147483646}

   _None=0
   VBoxGuestDriver=20
   VBoxService=100
   VBoxTrayClient=101
   Seamless=1000
   Graphics=1100
   All=2147483646

class AdditionsFacilityClass:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=AdditionsFacilityClass._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,AdditionsFacilityClass):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,AdditionsFacilityClass):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return AdditionsFacilityClass._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'None',10:'Driver',30:'Service',50:'Program',100:'Feature',999:'ThirdParty',2147483646:'All'}
   _ValueMap={
              'None':0,
              'Driver':10,
              'Service':30,
              'Program':50,
              'Feature':100,
              'ThirdParty':999,
              'All':2147483646}

   _None=0
   Driver=10
   Service=30
   Program=50
   Feature=100
   ThirdParty=999
   All=2147483646

class AdditionsFacilityStatus:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=AdditionsFacilityStatus._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,AdditionsFacilityStatus):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,AdditionsFacilityStatus):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return AdditionsFacilityStatus._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Inactive',1:'Paused',20:'PreInit',30:'Init',50:'Active',100:'Terminating',101:'Terminated',800:'Failed',999:'Unknown'}
   _ValueMap={
              'Inactive':0,
              'Paused':1,
              'PreInit':20,
              'Init':30,
              'Active':50,
              'Terminating':100,
              'Terminated':101,
              'Failed':800,
              'Unknown':999}

   Inactive=0
   Paused=1
   PreInit=20
   Init=30
   Active=50
   Terminating=100
   Terminated=101
   Failed=800
   Unknown=999

class AdditionsRunLevelType:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=AdditionsRunLevelType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,AdditionsRunLevelType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,AdditionsRunLevelType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return AdditionsRunLevelType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'None',1:'System',2:'Userland',3:'Desktop'}
   _ValueMap={
              'None':0,
              'System':1,
              'Userland':2,
              'Desktop':3}

   _None=0
   System=1
   Userland=2
   Desktop=3

class AdditionsUpdateFlag:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=AdditionsUpdateFlag._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,AdditionsUpdateFlag):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,AdditionsUpdateFlag):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return AdditionsUpdateFlag._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'None',1:'WaitForUpdateStartOnly'}
   _ValueMap={
              'None':0,
              'WaitForUpdateStartOnly':1}

   _None=0
   WaitForUpdateStartOnly=1

class ExecuteProcessFlag:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=ExecuteProcessFlag._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,ExecuteProcessFlag):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,ExecuteProcessFlag):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return ExecuteProcessFlag._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'None',1:'WaitForProcessStartOnly',2:'IgnoreOrphanedProcesses',4:'Hidden',8:'NoProfile'}
   _ValueMap={
              'None':0,
              'WaitForProcessStartOnly':1,
              'IgnoreOrphanedProcesses':2,
              'Hidden':4,
              'NoProfile':8}

   _None=0
   WaitForProcessStartOnly=1
   IgnoreOrphanedProcesses=2
   Hidden=4
   NoProfile=8

class ExecuteProcessStatus:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=ExecuteProcessStatus._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,ExecuteProcessStatus):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,ExecuteProcessStatus):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return ExecuteProcessStatus._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Undefined',1:'Started',2:'TerminatedNormally',3:'TerminatedSignal',4:'TerminatedAbnormally',5:'TimedOutKilled',6:'TimedOutAbnormally',7:'Down',8:'Error'}
   _ValueMap={
              'Undefined':0,
              'Started':1,
              'TerminatedNormally':2,
              'TerminatedSignal':3,
              'TerminatedAbnormally':4,
              'TimedOutKilled':5,
              'TimedOutAbnormally':6,
              'Down':7,
              'Error':8}

   Undefined=0
   Started=1
   TerminatedNormally=2
   TerminatedSignal=3
   TerminatedAbnormally=4
   TimedOutKilled=5
   TimedOutAbnormally=6
   Down=7
   Error=8

class ProcessInputFlag:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=ProcessInputFlag._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,ProcessInputFlag):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,ProcessInputFlag):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return ProcessInputFlag._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'None',1:'EndOfFile'}
   _ValueMap={
              'None':0,
              'EndOfFile':1}

   _None=0
   EndOfFile=1

class ProcessOutputFlag:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=ProcessOutputFlag._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,ProcessOutputFlag):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,ProcessOutputFlag):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return ProcessOutputFlag._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'None',1:'StdErr'}
   _ValueMap={
              'None':0,
              'StdErr':1}

   _None=0
   StdErr=1

class CopyFileFlag:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=CopyFileFlag._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,CopyFileFlag):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,CopyFileFlag):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return CopyFileFlag._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'None',1:'Recursive',2:'Update',4:'FollowLinks'}
   _ValueMap={
              'None':0,
              'Recursive':1,
              'Update':2,
              'FollowLinks':4}

   _None=0
   Recursive=1
   Update=2
   FollowLinks=4

class DirectoryCreateFlag:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=DirectoryCreateFlag._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,DirectoryCreateFlag):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,DirectoryCreateFlag):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return DirectoryCreateFlag._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'None',1:'Parents'}
   _ValueMap={
              'None':0,
              'Parents':1}

   _None=0
   Parents=1

class DirectoryOpenFlag:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=DirectoryOpenFlag._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,DirectoryOpenFlag):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,DirectoryOpenFlag):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return DirectoryOpenFlag._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'None'}
   _ValueMap={
              'None':0}

   _None=0

class GuestDirEntryType:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=GuestDirEntryType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,GuestDirEntryType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,GuestDirEntryType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return GuestDirEntryType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Unknown',4:'Directory',10:'File',12:'Symlink'}
   _ValueMap={
              'Unknown':0,
              'Directory':4,
              'File':10,
              'Symlink':12}

   Unknown=0
   Directory=4
   File=10
   Symlink=12

class MediumState:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=MediumState._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,MediumState):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,MediumState):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return MediumState._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'NotCreated',1:'Created',2:'LockedRead',3:'LockedWrite',4:'Inaccessible',5:'Creating',6:'Deleting'}
   _ValueMap={
              'NotCreated':0,
              'Created':1,
              'LockedRead':2,
              'LockedWrite':3,
              'Inaccessible':4,
              'Creating':5,
              'Deleting':6}

   NotCreated=0
   Created=1
   LockedRead=2
   LockedWrite=3
   Inaccessible=4
   Creating=5
   Deleting=6

class MediumType:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=MediumType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,MediumType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,MediumType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return MediumType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Normal',1:'Immutable',2:'Writethrough',3:'Shareable',4:'Readonly',5:'MultiAttach'}
   _ValueMap={
              'Normal':0,
              'Immutable':1,
              'Writethrough':2,
              'Shareable':3,
              'Readonly':4,
              'MultiAttach':5}

   Normal=0
   Immutable=1
   Writethrough=2
   Shareable=3
   Readonly=4
   MultiAttach=5

class MediumVariant:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=MediumVariant._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,MediumVariant):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,MediumVariant):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return MediumVariant._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Standard',0x01:'VmdkSplit2G',0x04:'VmdkStreamOptimized',0x08:'VmdkESX',0x10000:'Fixed',0x20000:'Diff',0x40000000:'NoCreateDir'}
   _ValueMap={
              'Standard':0,
              'VmdkSplit2G':0x01,
              'VmdkStreamOptimized':0x04,
              'VmdkESX':0x08,
              'Fixed':0x10000,
              'Diff':0x20000,
              'NoCreateDir':0x40000000}

   Standard=0
   VmdkSplit2G=0x01
   VmdkStreamOptimized=0x04
   VmdkESX=0x08
   Fixed=0x10000
   Diff=0x20000
   NoCreateDir=0x40000000

class DataType:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=DataType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,DataType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,DataType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return DataType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Int32',1:'Int8',2:'String'}
   _ValueMap={
              'Int32':0,
              'Int8':1,
              'String':2}

   Int32=0
   Int8=1
   String=2

class DataFlags:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=DataFlags._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,DataFlags):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,DataFlags):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return DataFlags._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0x00:'None',0x01:'Mandatory',0x02:'Expert',0x04:'Array',0x07:'FlagMask'}
   _ValueMap={
              'None':0x00,
              'Mandatory':0x01,
              'Expert':0x02,
              'Array':0x04,
              'FlagMask':0x07}

   _None=0x00
   Mandatory=0x01
   Expert=0x02
   Array=0x04
   FlagMask=0x07

class MediumFormatCapabilities:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=MediumFormatCapabilities._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,MediumFormatCapabilities):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,MediumFormatCapabilities):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return MediumFormatCapabilities._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0x01:'Uuid',0x02:'CreateFixed',0x04:'CreateDynamic',0x08:'CreateSplit2G',0x10:'Differencing',0x20:'Asynchronous',0x40:'File',0x80:'Properties',0x100:'TcpNetworking',0x200:'VFS',0x3FF:'CapabilityMask'}
   _ValueMap={
              'Uuid':0x01,
              'CreateFixed':0x02,
              'CreateDynamic':0x04,
              'CreateSplit2G':0x08,
              'Differencing':0x10,
              'Asynchronous':0x20,
              'File':0x40,
              'Properties':0x80,
              'TcpNetworking':0x100,
              'VFS':0x200,
              'CapabilityMask':0x3FF}

   Uuid=0x01
   CreateFixed=0x02
   CreateDynamic=0x04
   CreateSplit2G=0x08
   Differencing=0x10
   Asynchronous=0x20
   File=0x40
   Properties=0x80
   TcpNetworking=0x100
   VFS=0x200
   CapabilityMask=0x3FF

class MouseButtonState:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=MouseButtonState._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,MouseButtonState):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,MouseButtonState):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return MouseButtonState._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0x01:'LeftButton',0x02:'RightButton',0x04:'MiddleButton',0x08:'WheelUp',0x10:'WheelDown',0x20:'XButton1',0x40:'XButton2',0x7F:'MouseStateMask'}
   _ValueMap={
              'LeftButton':0x01,
              'RightButton':0x02,
              'MiddleButton':0x04,
              'WheelUp':0x08,
              'WheelDown':0x10,
              'XButton1':0x20,
              'XButton2':0x40,
              'MouseStateMask':0x7F}

   LeftButton=0x01
   RightButton=0x02
   MiddleButton=0x04
   WheelUp=0x08
   WheelDown=0x10
   XButton1=0x20
   XButton2=0x40
   MouseStateMask=0x7F

class FramebufferPixelFormat:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=FramebufferPixelFormat._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,FramebufferPixelFormat):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,FramebufferPixelFormat):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return FramebufferPixelFormat._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Opaque',0x32424752:'FOURCC_RGB'}
   _ValueMap={
              'Opaque':0,
              'FOURCC_RGB':0x32424752}

   Opaque=0
   FOURCC_RGB=0x32424752

class NetworkAttachmentType:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=NetworkAttachmentType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,NetworkAttachmentType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,NetworkAttachmentType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return NetworkAttachmentType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Null',1:'NAT',2:'Bridged',3:'Internal',4:'HostOnly',5:'Generic'}
   _ValueMap={
              'Null':0,
              'NAT':1,
              'Bridged':2,
              'Internal':3,
              'HostOnly':4,
              'Generic':5}

   Null=0
   NAT=1
   Bridged=2
   Internal=3
   HostOnly=4
   Generic=5

class NetworkAdapterType:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=NetworkAdapterType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,NetworkAdapterType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,NetworkAdapterType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return NetworkAdapterType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Null',1:'Am79C970A',2:'Am79C973',3:'I82540EM',4:'I82543GC',5:'I82545EM',6:'Virtio'}
   _ValueMap={
              'Null':0,
              'Am79C970A':1,
              'Am79C973':2,
              'I82540EM':3,
              'I82543GC':4,
              'I82545EM':5,
              'Virtio':6}

   Null=0
   Am79C970A=1
   Am79C973=2
   I82540EM=3
   I82543GC=4
   I82545EM=5
   Virtio=6

class NetworkAdapterPromiscModePolicy:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=NetworkAdapterPromiscModePolicy._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,NetworkAdapterPromiscModePolicy):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,NetworkAdapterPromiscModePolicy):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return NetworkAdapterPromiscModePolicy._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={1:'Deny',2:'AllowNetwork',3:'AllowAll'}
   _ValueMap={
              'Deny':1,
              'AllowNetwork':2,
              'AllowAll':3}

   Deny=1
   AllowNetwork=2
   AllowAll=3

class PortMode:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=PortMode._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,PortMode):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,PortMode):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return PortMode._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Disconnected',1:'HostPipe',2:'HostDevice',3:'RawFile'}
   _ValueMap={
              'Disconnected':0,
              'HostPipe':1,
              'HostDevice':2,
              'RawFile':3}

   Disconnected=0
   HostPipe=1
   HostDevice=2
   RawFile=3

class USBDeviceState:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=USBDeviceState._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,USBDeviceState):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,USBDeviceState):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return USBDeviceState._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'NotSupported',1:'Unavailable',2:'Busy',3:'Available',4:'Held',5:'Captured'}
   _ValueMap={
              'NotSupported':0,
              'Unavailable':1,
              'Busy':2,
              'Available':3,
              'Held':4,
              'Captured':5}

   NotSupported=0
   Unavailable=1
   Busy=2
   Available=3
   Held=4
   Captured=5

class USBDeviceFilterAction:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=USBDeviceFilterAction._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,USBDeviceFilterAction):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,USBDeviceFilterAction):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return USBDeviceFilterAction._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Null',1:'Ignore',2:'Hold'}
   _ValueMap={
              'Null':0,
              'Ignore':1,
              'Hold':2}

   Null=0
   Ignore=1
   Hold=2

class AudioDriverType:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=AudioDriverType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,AudioDriverType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,AudioDriverType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return AudioDriverType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Null',1:'WinMM',2:'OSS',3:'ALSA',4:'DirectSound',5:'CoreAudio',6:'MMPM',7:'Pulse',8:'SolAudio'}
   _ValueMap={
              'Null':0,
              'WinMM':1,
              'OSS':2,
              'ALSA':3,
              'DirectSound':4,
              'CoreAudio':5,
              'MMPM':6,
              'Pulse':7,
              'SolAudio':8}

   Null=0
   WinMM=1
   OSS=2
   ALSA=3
   DirectSound=4
   CoreAudio=5
   MMPM=6
   Pulse=7
   SolAudio=8

class AudioControllerType:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=AudioControllerType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,AudioControllerType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,AudioControllerType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return AudioControllerType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'AC97',1:'SB16',2:'HDA'}
   _ValueMap={
              'AC97':0,
              'SB16':1,
              'HDA':2}

   AC97=0
   SB16=1
   HDA=2

class AuthType:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=AuthType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,AuthType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,AuthType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return AuthType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Null',1:'External',2:'Guest'}
   _ValueMap={
              'Null':0,
              'External':1,
              'Guest':2}

   Null=0
   External=1
   Guest=2

class StorageBus:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=StorageBus._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,StorageBus):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,StorageBus):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return StorageBus._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Null',1:'IDE',2:'SATA',3:'SCSI',4:'Floppy',5:'SAS'}
   _ValueMap={
              'Null':0,
              'IDE':1,
              'SATA':2,
              'SCSI':3,
              'Floppy':4,
              'SAS':5}

   Null=0
   IDE=1
   SATA=2
   SCSI=3
   Floppy=4
   SAS=5

class StorageControllerType:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=StorageControllerType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,StorageControllerType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,StorageControllerType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return StorageControllerType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Null',1:'LsiLogic',2:'BusLogic',3:'IntelAhci',4:'PIIX3',5:'PIIX4',6:'ICH6',7:'I82078',8:'LsiLogicSas'}
   _ValueMap={
              'Null':0,
              'LsiLogic':1,
              'BusLogic':2,
              'IntelAhci':3,
              'PIIX3':4,
              'PIIX4':5,
              'ICH6':6,
              'I82078':7,
              'LsiLogicSas':8}

   Null=0
   LsiLogic=1
   BusLogic=2
   IntelAhci=3
   PIIX3=4
   PIIX4=5
   ICH6=6
   I82078=7
   LsiLogicSas=8

class ChipsetType:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=ChipsetType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,ChipsetType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,ChipsetType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return ChipsetType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Null',1:'PIIX3',2:'ICH9'}
   _ValueMap={
              'Null':0,
              'PIIX3':1,
              'ICH9':2}

   Null=0
   PIIX3=1
   ICH9=2

class NATAliasMode:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=NATAliasMode._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,NATAliasMode):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,NATAliasMode):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return NATAliasMode._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0x1:'AliasLog',0x02:'AliasProxyOnly',0x04:'AliasUseSamePorts'}
   _ValueMap={
              'AliasLog':0x1,
              'AliasProxyOnly':0x02,
              'AliasUseSamePorts':0x04}

   AliasLog=0x1
   AliasProxyOnly=0x02
   AliasUseSamePorts=0x04

class NATProtocol:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=NATProtocol._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,NATProtocol):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,NATProtocol):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return NATProtocol._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'UDP',1:'TCP'}
   _ValueMap={
              'UDP':0,
              'TCP':1}

   UDP=0
   TCP=1

class BandwidthGroupType:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=BandwidthGroupType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,BandwidthGroupType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,BandwidthGroupType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return BandwidthGroupType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Null',1:'Disk',2:'Network'}
   _ValueMap={
              'Null':0,
              'Disk':1,
              'Network':2}

   Null=0
   Disk=1
   Network=2

class VBoxEventType:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=VBoxEventType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,VBoxEventType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,VBoxEventType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return VBoxEventType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Invalid',1:'Any',2:'Vetoable',3:'MachineEvent',4:'SnapshotEvent',5:'InputEvent',31:'LastWildcard',32:'OnMachineStateChanged',33:'OnMachineDataChanged',34:'OnExtraDataChanged',35:'OnExtraDataCanChange',36:'OnMediumRegistered',37:'OnMachineRegistered',38:'OnSessionStateChanged',39:'OnSnapshotTaken',40:'OnSnapshotDeleted',41:'OnSnapshotChanged',42:'OnGuestPropertyChanged',43:'OnMousePointerShapeChanged',44:'OnMouseCapabilityChanged',45:'OnKeyboardLedsChanged',46:'OnStateChanged',47:'OnAdditionsStateChanged',48:'OnNetworkAdapterChanged',49:'OnSerialPortChanged',50:'OnParallelPortChanged',51:'OnStorageControllerChanged',52:'OnMediumChanged',53:'OnVRDEServerChanged',54:'OnUSBControllerChanged',55:'OnUSBDeviceStateChanged',56:'OnSharedFolderChanged',57:'OnRuntimeError',58:'OnCanShowWindow',59:'OnShowWindow',60:'OnCPUChanged',61:'OnVRDEServerInfoChanged',62:'OnEventSourceChanged',63:'OnCPUExecutionCapChanged',64:'OnGuestKeyboard',65:'OnGuestMouse',66:'OnNATRedirect',67:'OnHostPciDevicePlug',68:'OnVBoxSVCAvailabilityChanged',69:'OnBandwidthGroupChanged',70:'OnGuestMonitorChanged',71:'OnStorageDeviceChanged',72:'Last'}
   _ValueMap={
              'Invalid':0,
              'Any':1,
              'Vetoable':2,
              'MachineEvent':3,
              'SnapshotEvent':4,
              'InputEvent':5,
              'LastWildcard':31,
              'OnMachineStateChanged':32,
              'OnMachineDataChanged':33,
              'OnExtraDataChanged':34,
              'OnExtraDataCanChange':35,
              'OnMediumRegistered':36,
              'OnMachineRegistered':37,
              'OnSessionStateChanged':38,
              'OnSnapshotTaken':39,
              'OnSnapshotDeleted':40,
              'OnSnapshotChanged':41,
              'OnGuestPropertyChanged':42,
              'OnMousePointerShapeChanged':43,
              'OnMouseCapabilityChanged':44,
              'OnKeyboardLedsChanged':45,
              'OnStateChanged':46,
              'OnAdditionsStateChanged':47,
              'OnNetworkAdapterChanged':48,
              'OnSerialPortChanged':49,
              'OnParallelPortChanged':50,
              'OnStorageControllerChanged':51,
              'OnMediumChanged':52,
              'OnVRDEServerChanged':53,
              'OnUSBControllerChanged':54,
              'OnUSBDeviceStateChanged':55,
              'OnSharedFolderChanged':56,
              'OnRuntimeError':57,
              'OnCanShowWindow':58,
              'OnShowWindow':59,
              'OnCPUChanged':60,
              'OnVRDEServerInfoChanged':61,
              'OnEventSourceChanged':62,
              'OnCPUExecutionCapChanged':63,
              'OnGuestKeyboard':64,
              'OnGuestMouse':65,
              'OnNATRedirect':66,
              'OnHostPciDevicePlug':67,
              'OnVBoxSVCAvailabilityChanged':68,
              'OnBandwidthGroupChanged':69,
              'OnGuestMonitorChanged':70,
              'OnStorageDeviceChanged':71,
              'Last':72}

   Invalid=0
   Any=1
   Vetoable=2
   MachineEvent=3
   SnapshotEvent=4
   InputEvent=5
   LastWildcard=31
   OnMachineStateChanged=32
   OnMachineDataChanged=33
   OnExtraDataChanged=34
   OnExtraDataCanChange=35
   OnMediumRegistered=36
   OnMachineRegistered=37
   OnSessionStateChanged=38
   OnSnapshotTaken=39
   OnSnapshotDeleted=40
   OnSnapshotChanged=41
   OnGuestPropertyChanged=42
   OnMousePointerShapeChanged=43
   OnMouseCapabilityChanged=44
   OnKeyboardLedsChanged=45
   OnStateChanged=46
   OnAdditionsStateChanged=47
   OnNetworkAdapterChanged=48
   OnSerialPortChanged=49
   OnParallelPortChanged=50
   OnStorageControllerChanged=51
   OnMediumChanged=52
   OnVRDEServerChanged=53
   OnUSBControllerChanged=54
   OnUSBDeviceStateChanged=55
   OnSharedFolderChanged=56
   OnRuntimeError=57
   OnCanShowWindow=58
   OnShowWindow=59
   OnCPUChanged=60
   OnVRDEServerInfoChanged=61
   OnEventSourceChanged=62
   OnCPUExecutionCapChanged=63
   OnGuestKeyboard=64
   OnGuestMouse=65
   OnNATRedirect=66
   OnHostPciDevicePlug=67
   OnVBoxSVCAvailabilityChanged=68
   OnBandwidthGroupChanged=69
   OnGuestMonitorChanged=70
   OnStorageDeviceChanged=71
   Last=72

class GuestMonitorChangedEventType:
   def __init__(self,mgr,handle):
       self.mgr=mgr
       if isinstance(handle,basestring):
           self.handle=GuestMonitorChangedEventType._ValueMap[handle]
       else:
           self.handle=handle

   def __eq__(self,other):
      if isinstance(other,GuestMonitorChangedEventType):
         return self.handle == other.handle
      if isinstance(other,int):
         return self.handle == other
      if isinstance(other,basestring):
         return str(self) == other
      return False

   def __ne__(self,other):
      if isinstance(other,GuestMonitorChangedEventType):
         return self.handle != other.handle
      if isinstance(other,int):
         return self.handle != other
      if isinstance(other,basestring):
         return str(self) != other
      return True

   def __str__(self):
        return GuestMonitorChangedEventType._NameMap[self.handle]

   def __int__(self):
        return self.handle

   _NameMap={0:'Enabled',1:'Disabled',2:'NewOrigin'}
   _ValueMap={
              'Enabled':0,
              'Disabled':1,
              'NewOrigin':2}

   Enabled=0
   Disabled=1
   NewOrigin=2


import base64

class IWebsessionManager2(IWebsessionManager):
  def __init__(self, url):
       self.url = url
       self.port = None
       self.handle = None
       self.mgr = self

  def getPort(self):
      if self.port is None:
          try:
             self.port = vboxServiceLocator().getvboxPortType(self.url)
          except:
             self.port = vboxServiceLocator().getvboxServicePort(self.url)
      return self.port

  def decodebase64(self, str):
      return base64.decodestring(str)

  def encodebase64(self, str):
      return base64.encodestring(str)

